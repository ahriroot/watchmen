<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","ahri","watchmen","common","src","arg.rs"],"content":"use clap::{Args, Parser, Subcommand};\n\n#[derive(Debug, Parser, PartialEq)]\n#[command(author, about)]\npub struct TaskArgs {\n    /// Config file path.\n    /// Default: $HOME/.watchmen/config.toml\n    #[arg(short, long)]\n    pub config: Option\u003cString\u003e,\n\n    /// Print version\n    #[arg(short, long)]\n    pub version: bool,\n\n    /// SubCommands\n    #[command(subcommand)]\n    pub commands: Option\u003cCommands\u003e,\n}\n\n#[derive(Debug, Subcommand, PartialEq)]\npub enum Commands {\n    /// Add and run a task\n    Run(RunArgs),\n}\n\n#[derive(Args, Debug, PartialEq)]\npub struct RunArgs {\n    /// Task config directory\n    #[arg(short = 'l', long)]\n    pub all: Option\u003cString\u003e,\n\n    /// Task config file\n    #[arg(short = 'f', long)]\n    pub config: Option\u003cString\u003e,\n\n    /// Task name (unique)\n    #[arg(short, long)]\n    pub name: String,\n\n    /// Task command\n    #[arg(short, long)]\n    pub command: String,\n\n    /// Task arguments\n    #[arg(short, long)]\n    pub args: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Task working directory\n    #[arg(short = 'd', long)]\n    pub dir: Option\u003cString\u003e,\n\n    /// Task environment variables\n    #[arg(short = 'e', long)]\n    pub env: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Task standard input\n    #[arg(short = 'i', long)]\n    pub stdin: Option\u003cString\u003e,\n\n    /// Task standard output\n    #[arg(short = 'o', long)]\n    pub stdout: Option\u003cString\u003e,\n\n    /// Task standard error\n    #[arg(short = 'r', long)]\n    pub stderr: Option\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","common","src","lib.rs"],"content":"pub mod arg;\npub mod task;\npub mod trait_arg;\npub mod trait_task;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","common","src","task.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::{\n    collections::HashMap,\n    time::{SystemTime, UNIX_EPOCH},\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct ScheduledTask {\n    pub year: Option\u003cu64\u003e,\n    pub month: Option\u003cu64\u003e,\n    pub day: Option\u003cu64\u003e,\n    pub hour: Option\u003cu64\u003e,\n    pub minute: Option\u003cu64\u003e,\n    pub second: Option\u003cu64\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct AsyncTask {\n    pub started_at: u64,\n    pub stopped_at: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct PeriodicTask {\n    pub started_after: u64,\n    pub interval: u64,\n    pub last_run: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub enum TaskType {\n    Scheduled(ScheduledTask),\n    Async(AsyncTask),\n    Periodic(PeriodicTask),\n    None,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Task {\n    /// Task id (unique)\n    pub id: i64,\n\n    /// Task name (unique)\n    pub name: String,\n\n    /// Task command\n    pub command: String,\n\n    /// Task arguments\n    pub args: Vec\u003cString\u003e,\n\n    /// Task working directory\n    pub dir: String,\n\n    /// Task environment variables\n    pub env: HashMap\u003cString, String\u003e,\n\n    pub stdin: Option\u003cString\u003e,\n    pub stdout: Option\u003cString\u003e,\n    pub stderr: Option\u003cString\u003e,\n\n    pub created_at: u64,\n    pub task_type: TaskType,\n}\n\nimpl Default for Task {\n    fn default() -\u003e Self {\n        let now = SystemTime::now();\n        let timestamp = now\n            .duration_since(UNIX_EPOCH)\n            .expect(\"Failed to get timestamp\")\n            .as_secs();\n        Task {\n            id: 0,\n            name: \"\".to_string(),\n            command: \"\".to_string(),\n            args: vec![],\n            dir: \"\".to_string(),\n            env: HashMap::new(),\n            stdin: None,\n            stdout: None,\n            stderr: None,\n            created_at: timestamp,\n            task_type: TaskType::None,\n        }\n    }\n}\n\nunsafe impl Send for Task {}\nunsafe impl Sync for Task {}\n","traces":[{"line":67,"address":[732112,732990],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":68,"address":[732128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[732163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[732268],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[732317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[732365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[732425],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[732492],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","ahri","watchmen","common","src","trait_arg.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","common","src","trait_task.rs"],"content":"use std::error::Error;\n\nuse configparser::ini::Ini;\n\nuse crate::task::{AsyncTask, PeriodicTask, ScheduledTask, Task, TaskType};\n\nimpl Task {\n    pub fn from_ini(args: Ini, section: \u0026str) -\u003e Result\u003cTask, Box\u003cdyn Error\u003e\u003e {\n        let mut task = Task::default();\n        task.id = args.getint(section, \"id\")?.unwrap();\n        task.name = args.get(section, \"name\").unwrap();\n        task.command = args.get(section, \"command\").unwrap();\n        task.args = args\n            .get(section, \"args\")\n            .unwrap_or(\"\".to_string())\n            .split(\" \")\n            .map(|s| s.to_string())\n            .collect();\n        task.dir = args\n            .get(section, \"dir\")\n            .unwrap_or(std::env::current_dir()?.to_str().unwrap().to_string());\n        for env in args\n            .get(section, \"env\")\n            .unwrap_or(\"\".to_string())\n            .split(\" \")\n        {\n            let kv: Vec\u003c\u0026str\u003e = env.split(\"=\").collect();\n            if kv.len() == 2 {\n                task.env.insert(kv[0].to_string(), kv[1].to_string());\n            }\n        }\n        task.stdin = args.get(section, \"stdin\");\n        task.stdout = args.get(section, \"stdout\");\n        task.stderr = args.get(section, \"stderr\");\n\n        let task_type = args.get(section, \"task_type\").unwrap_or(\"none\".to_string());\n\n        let tt = match task_type.as_str() {\n            \"scheduled\" =\u003e {\n                let mut tt = ScheduledTask {\n                    year: None,\n                    month: None,\n                    day: None,\n                    hour: None,\n                    minute: None,\n                    second: None,\n                };\n                if let Some(year) = args.getint(section, \"year\")? {\n                    if year \u003c 1970 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid year: {}\", year),\n                        )));\n                    }\n                    tt.year = Some(year as u64);\n                }\n                if let Some(month) = args.getint(section, \"month\")? {\n                    if month \u003c 1 || month \u003e 12 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid month: {}\", month),\n                        )));\n                    }\n                    tt.month = Some(month as u64);\n                }\n                if let Some(day) = args.getint(section, \"day\")? {\n                    if day \u003c 1 || day \u003e 31 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid day: {}\", day),\n                        )));\n                    }\n                    tt.day = Some(day as u64);\n                }\n                if let Some(hour) = args.getint(section, \"hour\")? {\n                    if hour \u003c 0 || hour \u003e 23 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid hour: {}\", hour),\n                        )));\n                    }\n                    tt.hour = Some(hour as u64);\n                }\n                if let Some(minute) = args.getint(section, \"minute\")? {\n                    if minute \u003c 0 || minute \u003e 59 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid minute: {}\", minute),\n                        )));\n                    }\n                    tt.minute = Some(minute as u64);\n                }\n                if let Some(second) = args.getint(section, \"second\")? {\n                    if second \u003c 0 || second \u003e 59 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid second: {}\", second),\n                        )));\n                    }\n                    tt.second = Some(second as u64);\n                }\n                TaskType::Scheduled(tt)\n            }\n            \"async\" =\u003e TaskType::Async(AsyncTask {\n                started_at: 0,\n                stopped_at: 0,\n            }),\n            \"periodic\" =\u003e {\n                let mut tt = PeriodicTask {\n                    started_after: 0,\n                    interval: 60,\n                    last_run: 0,\n                };\n                if let Some(started_after) = args.getint(section, \"started_after\")? {\n                    if started_after \u003c 0 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid started_after: {}\", started_after),\n                        )));\n                    }\n                    tt.started_after = started_after as u64;\n                }\n                if let Some(interval) = args.getint(section, \"interval\")? {\n                    if interval \u003c= 0 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid interval: {}\", interval),\n                        )));\n                    }\n                    tt.interval = interval as u64;\n                }\n                TaskType::Periodic(tt)\n            }\n            _ =\u003e {\n                return Err(Box::new(std::io::Error::new(\n                    std::io::ErrorKind::Other,\n                    format!(\"Invalid task_type: {}\", task_type),\n                )));\n            }\n        };\n        task.task_type = tt;\n\n        Ok(task)\n    }\n}\n","traces":[{"line":8,"address":[733024,734344,745963],"length":1,"stats":{"Line":1},"fn_name":"from_ini"},{"line":9,"address":[733093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[733301,733438,733673],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[733681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[733913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[734145,734248,734423],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[734177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[734415,734185,734322],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[764821,764768],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":18,"address":[734651,734355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[735247,735298,735358,734694],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[734726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[735478,735290,735317,734734,735086],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[735521,735788,736025,735720,735624],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[735553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[735780,735561,735698],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[736008,736057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[736116,736195,736272],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[736304,736201],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[736571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[736769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[736967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[737165,737354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[737328,737727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[737857,737749],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[738138,738363,738417,738554],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[738397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[738925,738734],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[738556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[738494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[739387,739309,739173,738952,738459],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[739250,739160],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[739570,739761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[739392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[739327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[739215,739788,740145,740009,740223],"length":1,"stats":{"Line":5},"fn_name":null},{"line":67,"address":[740086,739996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[740406,740597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[740228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[740163],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[741059,740051,740845,740624,740981],"length":1,"stats":{"Line":6},"fn_name":null},{"line":76,"address":[740922,740832],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[741242,741433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[741064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[740999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[740887,741681,741817,741460,741895],"length":1,"stats":{"Line":6},"fn_name":null},{"line":85,"address":[741668,741758],"length":1,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[742269,742078],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[741900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[741835],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[742651,742296,742517,741723,742729],"length":1,"stats":{"Line":6},"fn_name":null},{"line":94,"address":[742592,742504],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[742912,743103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[742734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[742669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[742535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[743530,737804,743485],"length":1,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[743507,743625],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[744086,743993,743740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[743980],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[744254,744430],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[744088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[744070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[744685,744035,744457,744816,744850],"length":1,"stats":{"Line":4},"fn_name":null},{"line":124,"address":[744665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[745021,745197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[744855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[744834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[744703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[745611,745438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[743631,745328],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[743130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[743322],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":73,"coverable":73},{"path":["/","home","ahri","watchmen","common","tests","arg_test.rs"],"content":"#[cfg(test)]\nmod tests {\n    use clap::Parser;\n    use common::arg::{Commands, RunArgs, TaskArgs};\n\n    #[test]\n    fn test_arg() {\n        let args = TaskArgs::parse_from([\"--\", \"-v\"]);\n        assert!(args.version);\n\n        let args = TaskArgs::parse_from([\"--\", \"run\", \"-n\", \"test\", \"-c\", \"rustc\"]);\n        let cmd = Commands::Run(RunArgs {\n            all: None,\n            config: None,\n            name: \"test\".to_string(),\n            command: \"rustc\".to_string(),\n            args: None,\n            dir: None,\n            env: None,\n            stdin: None,\n            stdout: None,\n            stderr: None,\n        });\n        assert_eq!(args.commands, Some(cmd));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","common","tests","task_from_ini_test.rs"],"content":"#[cfg(test)]\nmod tests {\n    use std::collections::HashMap;\n\n    use common::task::{AsyncTask, PeriodicTask, ScheduledTask, Task, TaskType};\n    use configparser::ini::Ini;\n\n    #[test]\n    fn test_task_from_ini_0() {\n        let mut ini = Ini::new();\n        let config_path = std::env::current_dir().unwrap().join(\"tests/ini/task.ini\");\n        ini.load(\u0026config_path).unwrap();\n\n        let mut sections_reality = ini.sections();\n        assert_eq!(sections_reality.len(), 3);\n\n        let mut sections_expect = vec![\n            \"test_section_name1\",\n            \"test_section_name2\",\n            \"test_section_name3\",\n        ];\n        assert_eq!(sections_reality.sort(), sections_expect.sort());\n\n        let mut task = Task::from_ini(ini.clone(), \"test_section_name1\").unwrap();\n        let mut env = HashMap::new();\n        env.insert(\"key1\".to_string(), \"value1\".to_string());\n        env.insert(\"key2\".to_string(), \"value2\".to_string());\n        task.created_at = 0;\n        assert_eq!(\n            task,\n            Task {\n                id: 1,\n                name: \"test_name1\".to_string(),\n                command: \"test_command\".to_string(),\n                args: vec![\"arg1\".to_string(), \"arg2\".to_string()],\n                dir: \"/home/user\".to_string(),\n                env,\n                stdin: Some(\"test_stdin\".to_string()),\n                stdout: Some(\"test_stdout\".to_string()),\n                stderr: Some(\"test_stderr\".to_string()),\n                created_at: 0,\n                task_type: TaskType::Scheduled(ScheduledTask {\n                    year: Some(2000),\n                    month: Some(1),\n                    day: Some(1),\n                    hour: Some(1),\n                    minute: Some(1),\n                    second: Some(1),\n                })\n            }\n        );\n\n        let mut task = Task::from_ini(ini.clone(), \"test_section_name2\").unwrap();\n        let mut env = HashMap::new();\n        env.insert(\"key1\".to_string(), \"value1\".to_string());\n        env.insert(\"key2\".to_string(), \"value2\".to_string());\n        task.created_at = 0;\n        assert_eq!(\n            task,\n            Task {\n                id: 2,\n                name: \"test_name2\".to_string(),\n                command: \"test_command\".to_string(),\n                args: vec![\"arg1\".to_string(), \"arg2\".to_string()],\n                dir: \"/home/user\".to_string(),\n                env,\n                stdin: None,\n                stdout: None,\n                stderr: None,\n                created_at: 0,\n                task_type: TaskType::Async(AsyncTask {\n                    started_at: 0,\n                    stopped_at: 0,\n                })\n            }\n        );\n\n        let mut task = Task::from_ini(ini.clone(), \"test_section_name3\").unwrap();\n        let mut env = HashMap::new();\n        env.insert(\"key1\".to_string(), \"value1\".to_string());\n        env.insert(\"key2\".to_string(), \"value2\".to_string());\n        task.created_at = 0;\n        assert_eq!(\n            task,\n            Task {\n                id: 3,\n                name: \"test_name3\".to_string(),\n                command: \"test_command\".to_string(),\n                args: vec![\"arg1\".to_string(), \"arg2\".to_string()],\n                dir: \"/home/user\".to_string(),\n                env,\n                stdin: None,\n                stdout: None,\n                stderr: None,\n                created_at: 0,\n                task_type: TaskType::Periodic(PeriodicTask {\n                    started_after: 10000,\n                    interval: 600,\n                    last_run: 0,\n                })\n            }\n        );\n    }\n\n    #[test]\n    fn test_task_from_ini_1() {\n        let mut ini = Ini::new();\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_year_1969.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid year: 1969\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_month_13.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid month: 13\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_day_32.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid day: 32\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_hour_24.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid hour: 24\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_minute_60.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid minute: 60\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_second_60.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid second: 60\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_task_type_none.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid task_type: xxx\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_started_after.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid started_after: -1\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_interval.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid interval: 0\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","add.rs"],"content":"use std::error::Error;\n\nuse crate::entity::{self, Task};\nuse crate::global::{add_task, check_exists};\n\nasync fn register(task: Task) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    add_task(task).await?;\n    Ok(())\n}\n\npub async fn add_a_task(task: Task) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let args_cmdline: Vec\u003cString\u003e = std::env::args().collect();\n    if args_cmdline.len() \u003c 3 {\n        return Ok(entity::Response {\n            code: 50000,\n            msg: \"Miss stdout path\".to_string(),\n            data: None,\n        });\n    }\n\n    let exists = check_exists(task.name.clone()).await?;\n    if exists {\n        return Ok(entity::Response {\n            code: 40000,\n            msg: \"Task already exists\".to_string(),\n            data: None,\n        });\n    }\n\n    let t = task.clone();\n    register(t).await?;\n\n    return Ok(entity::Response {\n        code: 10000,\n        msg: \"Task added successfully\".to_string(),\n        data: None,\n    });\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","exit.rs"],"content":"use std::error::Error;\n\nuse crate::{\n    entity,\n    global::{get_task_by_id, get_task_by_name, get_task_by_pid, remove_task_by_name},\n};\n\nextern \"C\" {\n    pub fn kill(pid: i32, sig: i32) -\u003e i32;\n}\n\npub async fn exit_task(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let task;\n    if command.options.contains_key(\"id\") {\n        let id = command.options.get(\"id\").unwrap();\n        if let entity::Opt::U128(ref i) = id {\n            task = get_task_by_id(*i).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'id' must be a usize\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"name\") {\n        let name = command.options.get(\"name\").unwrap();\n        if let entity::Opt::Str(ref s) = name {\n            task = get_task_by_name(s.clone()).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'name' must be a string\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"pid\") {\n        let name = command.options.get(\"pid\").unwrap();\n        if let entity::Opt::U32(ref s) = name {\n            task = get_task_by_pid(*s).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'pid' must be a number\".to_string(),\n                data: None,\n            });\n        }\n    } else {\n        if command.args.len() == 0 {\n            return Ok(entity::Response {\n                code: 40000,\n                msg: \"Arg 'name' or 'pid' is required\".to_string(),\n                data: None,\n            });\n        } else {\n            task = get_task_by_name(command.args[0].clone()).await?;\n        }\n    }\n\n    let pid = task.pid;\n    if task.status == \"running\" {\n        let res = unsafe { kill(pid as i32, 15) };\n        if res == 0 {\n            remove_task_by_name(task.name).await?;\n            let res = entity::Response {\n                code: 10000,\n                msg: format!(\"{} success\", command.name),\n                data: None,\n            };\n            return Ok(res);\n        }\n        let res = entity::Response {\n            code: 40000,\n            msg: \"failed\".to_string(),\n            data: None,\n        };\n        return Ok(res);\n    } else {\n        remove_task_by_name(task.name).await?;\n        let res = entity::Response {\n            code: 10000,\n            msg: format!(\"{} success\", command.name),\n            data: None,\n        };\n        return Ok(res);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","list.rs"],"content":"use std::error::Error;\n\nuse crate::{\n    entity::{self, Task},\n    global::get_all_tasks,\n};\n\npub async fn list_tasks(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let mut task_list: Vec\u003cTask\u003e = Vec::new();\n    let tasks = get_all_tasks().await?;\n\n    for task in tasks.iter() {\n        let mut flag = true;\n        for (key, value) in command.options.iter() {\n            if key == \"name\" {\n                match value {\n                    entity::Opt::Str(ref s) =\u003e {\n                        if !task.name.contains(s) {\n                            flag = false;\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n            if key == \"status\" {\n                match value {\n                    entity::Opt::Str(ref s) =\u003e {\n                        if !task.status.contains(s) {\n                            flag = false;\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n            if key == \"pid\" {\n                match value {\n                    entity::Opt::U32(ref s) =\u003e {\n                        if task.pid != *s {\n                            flag = false;\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n        }\n        if flag {\n            task_list.push(task.clone());\n        }\n    }\n\n    let res = entity::Response {\n        code: 10000,\n        msg: format!(\"{} success\", command.name),\n        data: Some(entity::Data::TaskList(task_list)),\n    };\n    Ok(res)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","pause.rs"],"content":"use std::error::Error;\n\nuse crate::{\n    entity,\n    global::{get_task_by_id, get_task_by_name, get_task_by_pid, update_status_by_name},\n};\n\npub async fn pause_task(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let task;\n    if command.options.contains_key(\"id\") {\n        let id = command.options.get(\"id\").unwrap();\n        if let entity::Opt::U128(ref i) = id {\n            task = get_task_by_id(*i).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'id' must be a usize\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"name\") {\n        let name = command.options.get(\"name\").unwrap();\n        if let entity::Opt::Str(ref s) = name {\n            task = get_task_by_name(s.clone()).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'name' must be a string\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"pid\") {\n        let name = command.options.get(\"pid\").unwrap();\n        if let entity::Opt::U32(ref s) = name {\n            task = get_task_by_pid(*s).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'pid' must be a number\".to_string(),\n                data: None,\n            });\n        }\n    } else {\n        if command.args.len() == 0 {\n            return Ok(entity::Response {\n                code: 40000,\n                msg: \"Arg 'name' or 'pid' is required\".to_string(),\n                data: None,\n            });\n        } else {\n            task = get_task_by_name(command.args[0].clone()).await?;\n        }\n    }\n\n    if task.status != \"interval\" {\n        return Ok(entity::Response {\n            code: 40000,\n            msg: \"Task is not interval\".to_string(),\n            data: None,\n        });\n    }\n\n    update_status_by_name(task.name, \"paused\".to_string()).await?;\n\n    let res = entity::Response {\n        code: 10000,\n        msg: format!(\"{} success\", command.name),\n        data: None,\n    };\n    return Ok(res);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","restart.rs"],"content":"use std::error::Error;\n\nuse crate::entity;\n\nuse super::start;\nuse super::stop;\n\npub async fn restart_task(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let res1 = stop::stop_task(command.clone()).await?;\n    if res1.code == 10000 {\n        let res2 = start::start_task(command).await?;\n        if res2.code == 10000 {\n            return Ok(entity::Response {\n                code: 10000,\n                msg: \"restart success\".to_string(),\n                data: None,\n            });\n        } else {\n            return Ok(res2);\n        }\n    } else {\n        return Ok(res1);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","resume.rs"],"content":"use std::error::Error;\n\nuse crate::entity;\nuse crate::global::{get_task_by_id, get_task_by_name, update_status_by_name};\n\npub async fn resume_task(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let task;\n    if command.options.contains_key(\"id\") {\n        let id = command.options.get(\"id\").unwrap();\n        if let entity::Opt::U128(ref i) = id {\n            task = get_task_by_id(*i).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'id' must be a usize\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"name\") {\n        let name = command.options.get(\"name\").unwrap();\n        if let entity::Opt::Str(ref s) = name {\n            task = get_task_by_name(s.clone()).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'name' must be a string\".to_string(),\n                data: None,\n            });\n        }\n    } else {\n        if command.args.len() == 0 {\n            return Ok(entity::Response {\n                code: 40000,\n                msg: \"Arg 'name' is required\".to_string(),\n                data: None,\n            });\n        } else {\n            task = get_task_by_name(command.args[0].clone()).await?;\n        }\n    }\n\n    if task.status != \"paused\" \u0026\u0026 task.status != \"waiting\" {\n        return Ok(entity::Response {\n            code: 40000,\n            msg: format!(\"Task with '{}' could not be resumed\", task.status),\n            data: None,\n        });\n    }\n\n    update_status_by_name(task.name, \"interval\".to_string()).await?;\n\n    let res = entity::Response {\n        code: 10000,\n        msg: format!(\"{} success\", command.name),\n        data: None,\n    };\n    return Ok(res);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","run.rs"],"content":"use chrono::prelude::{DateTime, Local};\nuse std::{env, error::Error, path::Path, process::Stdio};\nuse tokio::process::{Child, Command};\n\nuse crate::entity::{self, Task};\nuse crate::global::{\n    add_task, check_exists, update_exit_code_by_name, update_pid_by_name, update_started_at_by_id,\n    update_status_by_name,\n};\n\nasync fn register(task: Task) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    add_task(task).await?;\n    Ok(())\n}\n\nasync fn update_pid(name: String, pid: u32) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    update_pid_by_name(name, pid).await?;\n    Ok(())\n}\n\nasync fn update_status(name: String, status: String) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    update_status_by_name(name, status).await?;\n    Ok(())\n}\n\npub async fn run_task(task: Task) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let args_cmdline: Vec\u003cString\u003e = std::env::args().collect();\n    if args_cmdline.len() \u003c 3 {\n        return Ok(entity::Response {\n            code: 50000,\n            msg: \"Miss stdout path\".to_string(),\n            data: None,\n        });\n    }\n\n    let exists = check_exists(task.name.clone()).await?;\n    if exists {\n        return Ok(entity::Response {\n            code: 40000,\n            msg: \"Task already exists\".to_string(),\n            data: None,\n        });\n    }\n\n    let t = task.clone();\n    register(t).await?;\n\n    // 声明指向文件的 stdout\n    let path = Path::new(\u0026args_cmdline[3]);\n    let path = path.join(format!(\"{}.log\", task.name));\n\n    // 创建或追加文件\n    let file = std::fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(path)?;\n\n    let stdout = Stdio::from(file);\n\n    let time: DateTime\u003cLocal\u003e = Local::now();\n    let now = time.timestamp_millis() as u128;\n\n    crate::info!(\"TASK\\tRUN\\t{:?}\", task);\n\n    // 获取环境变量 PATH\n    let env_path = env::var(\"PATH\")?;\n    let mut child: Child = Command::new(\u0026task.command)\n        .args(\u0026task.args)\n        .env(\"PATH\", env_path)\n        .stdin(Stdio::null())\n        .stdout(stdout)\n        .stderr(Stdio::null())\n        .spawn()?;\n\n    let result = child.id();\n\n    let code = match result {\n        Some(pid) =\u003e {\n            // 更改 task pid\n            update_pid(task.name.clone(), pid).await.unwrap();\n            // 更改 task status\n            update_status(task.name.clone(), \"running\".to_string())\n                .await\n                .unwrap();\n            update_started_at_by_id(task.id, now).await.unwrap();\n            // 异步等待子进程结束并更改 task status\n            tokio::spawn(async move {\n                let s = child.wait().await.unwrap();\n                let exit_code = s.code().unwrap_or(-1);\n                crate::info!(\"TASK\\tSTOP\\t{}\\t{:?}\", exit_code, task);\n                update_status(task.name.clone(), \"stopped\".to_string())\n                    .await\n                    .unwrap();\n                update_pid(task.name.clone(), 0).await.unwrap();\n                if let Some(code) = s.code() {\n                    update_exit_code_by_name(task.name.clone(), code as u32)\n                        .await\n                        .unwrap();\n                }\n            });\n            10000\n        }\n        None =\u003e 40000,\n    };\n    if code \u003e 0 {\n        return Ok(entity::Response {\n            code: 10000,\n            msg: \"run success\".to_string(),\n            data: None,\n        });\n    } else {\n        return Ok(entity::Response {\n            code: 40000,\n            msg: \"run failed\".to_string(),\n            data: None,\n        });\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","start.rs"],"content":"use chrono::prelude::{DateTime, Local};\nuse std::{env, error::Error, path::Path, process::Stdio};\nuse tokio::process::{Child, Command};\n\nuse crate::entity;\nuse crate::global::{\n    get_task_by_id, get_task_by_name, update_exit_code_by_name, update_pid_by_name,\n    update_started_at_by_id, update_status_by_name,\n};\n\nasync fn update_pid(name: String, pid: u32) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    update_pid_by_name(name, pid).await?;\n    Ok(())\n}\n\nasync fn update_status(name: String, status: String) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    update_status_by_name(name, status).await?;\n    Ok(())\n}\n\npub async fn start_task_by_task(task: entity::Task) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let args_cmdline: Vec\u003cString\u003e = std::env::args().collect();\n    if args_cmdline.len() \u003c 3 {\n        return Ok(entity::Response {\n            code: 50000,\n            msg: \"Miss stdout path\".to_string(),\n            data: None,\n        });\n    }\n\n    // 声明指向文件的 stdout\n    let path = Path::new(\u0026args_cmdline[3]);\n    let path = path.join(format!(\"{}.log\", task.name));\n\n    // 创建或追加文件\n    let file = std::fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(path)?;\n    let stdout = Stdio::from(file);\n\n    // 获取环境变量 PATH\n    let env_path = env::var(\"PATH\")?;\n    let mut child: Child = Command::new(\u0026task.command)\n        .args(\u0026task.args)\n        .env(\"PATH\", env_path)\n        .stdin(Stdio::null())\n        .stdout(stdout)\n        .stderr(Stdio::null())\n        .spawn()?;\n\n    let result = child.id();\n\n    match result {\n        Some(pid) =\u003e {\n            // 更改 task pid\n            update_pid(task.name.clone(), pid).await?;\n            // 更改 task status\n            update_status(task.name.clone(), \"running\".to_string()).await?;\n            // 异步等待子进程结束并更改 task status\n            tokio::spawn(async move {\n                let s = child.wait().await.unwrap();\n                update_status(task.name.clone(), \"stopped\".to_string())\n                    .await\n                    .unwrap();\n                update_pid(task.name.clone(), 0).await.unwrap();\n                if let Some(code) = s.code() {\n                    update_exit_code_by_name(task.name.clone(), code as u32)\n                        .await\n                        .unwrap();\n                }\n            });\n            Ok(entity::Response {\n                code: 10000,\n                msg: \"start success\".to_string(),\n                data: None,\n            })\n        }\n        None =\u003e Ok(entity::Response {\n            code: 40000,\n            msg: \"start failed\".to_string(),\n            data: None,\n        }),\n    }\n}\n\npub async fn start_task(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let task;\n    if command.options.contains_key(\"id\") {\n        let id = command.options.get(\"id\").unwrap();\n        if let entity::Opt::U128(ref i) = id {\n            task = get_task_by_id(*i).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'id' must be a usize\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"name\") {\n        let name = command.options.get(\"name\").unwrap();\n        if let entity::Opt::Str(ref s) = name {\n            task = get_task_by_name(s.clone()).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'name' must be a string\".to_string(),\n                data: None,\n            });\n        }\n    } else {\n        if command.args.len() == 0 {\n            return Ok(entity::Response {\n                code: 40000,\n                msg: \"Arg 'name' is required\".to_string(),\n                data: None,\n            });\n        } else {\n            task = get_task_by_name(command.args[0].clone()).await?;\n        }\n    }\n\n    if task.status != \"stopped\" \u0026\u0026 task.status != \"added\" {\n        return Ok(entity::Response {\n            code: 40000,\n            msg: format!(\"Task with '{}' could not be started\", task.status),\n            data: None,\n        });\n    }\n\n    let args_cmdline: Vec\u003cString\u003e = std::env::args().collect();\n    if args_cmdline.len() \u003c 3 {\n        return Ok(entity::Response {\n            code: 50000,\n            msg: \"Miss stdout path\".to_string(),\n            data: None,\n        });\n    }\n\n    // 声明指向文件的 stdout\n    let path = Path::new(\u0026args_cmdline[3]);\n    let path = path.join(format!(\"{}.log\", task.name));\n\n    // 创建或追加文件\n    let file = std::fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(path)?;\n    let stdout = Stdio::from(file);\n\n    let time: DateTime\u003cLocal\u003e = Local::now();\n    let now = time.timestamp_millis() as u128;\n\n    crate::info!(\"TASK\\tSTART\\t{:?}\", task);\n\n    // 获取环境变量 PATH\n    let env_path = env::var(\"PATH\")?;\n    let mut child: Child = Command::new(\u0026task.command)\n        .args(\u0026task.args)\n        .env(\"PATH\", env_path)\n        .stdin(Stdio::null())\n        .stdout(stdout)\n        .stderr(Stdio::null())\n        .spawn()?;\n\n    let result = child.id();\n\n    match result {\n        Some(pid) =\u003e {\n            // 更改 task pid\n            update_pid(task.name.clone(), pid).await.unwrap();\n            // 更改 task status\n            update_status(task.name.clone(), \"running\".to_string())\n                .await\n                .unwrap();\n            update_started_at_by_id(task.id, now).await.unwrap();\n            // 异步等待子进程结束并更改 task status\n            tokio::spawn(async move {\n                let s = child.wait().await.unwrap();\n                let exit_code = s.code().unwrap_or(-1);\n                crate::info!(\"TASK\\tSTOP\\t{}\\t{:?}\", exit_code, task);\n                update_status(task.name.clone(), \"stopped\".to_string())\n                    .await\n                    .unwrap();\n                update_pid(task.name.clone(), 0).await.unwrap();\n                if let Some(code) = s.code() {\n                    update_exit_code_by_name(task.name.clone(), code as u32)\n                        .await\n                        .unwrap();\n                }\n            });\n            Ok(entity::Response {\n                code: 10000,\n                msg: format!(\"{} success\", command.name),\n                data: None,\n            })\n        }\n        None =\u003e Ok(entity::Response {\n            code: 40000,\n            msg: format!(\"{} failed\", command.name),\n            data: None,\n        }),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","stop.rs"],"content":"use std::{env, error::Error, process::Stdio};\n\nuse tokio::process::{Child, Command};\n\nuse crate::{\n    entity,\n    global::{\n        get_task_by_id, get_task_by_name, get_task_by_pid, update_pid_by_name,\n        update_status_by_name,\n    },\n};\n\npub async fn kill_process(pid: u32) -\u003e Result\u003ci32, Box\u003cdyn Error\u003e\u003e {\n    let env_path = env::var(\"PATH\")?;\n    let mut child: Child = Command::new(\"kill\")\n        .arg(\"-9\")\n        .arg(pid.to_string())\n        .env(\"PATH\", env_path)\n        .stdin(Stdio::null())\n        .stdout(Stdio::null())\n        .stderr(Stdio::null())\n        .spawn()?;\n    let res_exit = child.wait().await;\n    let code = match res_exit {\n        Ok(exit) =\u003e exit.code().unwrap_or(0),\n        Err(_) =\u003e -1,\n    };\n    Ok(code)\n}\n\npub async fn stop_task(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let task;\n    if command.options.contains_key(\"id\") {\n        let id = command.options.get(\"id\").unwrap();\n        if let entity::Opt::U128(ref i) = id {\n            task = get_task_by_id(*i).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'id' must be a usize\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"name\") {\n        let name = command.options.get(\"name\").unwrap();\n        if let entity::Opt::Str(ref s) = name {\n            task = get_task_by_name(s.clone()).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'name' must be a string\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"pid\") {\n        let name = command.options.get(\"pid\").unwrap();\n        if let entity::Opt::U32(ref s) = name {\n            task = get_task_by_pid(*s).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'pid' must be a number\".to_string(),\n                data: None,\n            });\n        }\n    } else {\n        if command.args.len() == 0 {\n            return Ok(entity::Response {\n                code: 40000,\n                msg: \"Arg 'name' or 'pid' is required\".to_string(),\n                data: None,\n            });\n        } else {\n            task = get_task_by_name(command.args[0].clone()).await?;\n        }\n    }\n\n    if task.status != \"running\" {\n        return Ok(entity::Response {\n            code: 40000,\n            msg: \"Task is not running\".to_string(),\n            data: None,\n        });\n    }\n\n    let pid = task.pid;\n\n    if pid \u003c= 3 {\n        let res = entity::Response {\n            code: 10000,\n            msg: format!(\"{} success\", command.name),\n            data: None,\n        };\n        return Ok(res);\n    }\n\n    let res = match kill_process(pid).await {\n        Ok(code) =\u003e code,\n        Err(_) =\u003e -1,\n    };\n    if res == 0 {\n        update_status_by_name(task.name.clone(), \"stopped\".to_string()).await?;\n        update_pid_by_name(task.name, 0).await?;\n        let res = entity::Response {\n            code: 10000,\n            msg: format!(\"{} success\", command.name),\n            data: None,\n        };\n        return Ok(res);\n    }\n    let res = entity::Response {\n        code: 40000,\n        msg: \"failed\".to_string(),\n        data: None,\n    };\n    return Ok(res);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command.rs"],"content":"pub mod add;\npub mod exit;\npub mod list;\npub mod pause;\npub mod restart;\npub mod resume;\npub mod run;\npub mod start;\npub mod stop;\n\nuse std::error::Error;\n\nuse chrono::Local;\n\nuse crate::{\n    command,\n    entity::{self, Task},\n    utils::get_id,\n};\n\npub async fn handle_exec(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    crate::info!(\"COMMAND\\t{:?}\", command);\n    match command.name.as_str() {\n        \"terminated\" =\u003e {\n            return Ok(entity::Response {\n                code: 10,\n                msg: \"Daemon terminated.\".to_string(),\n                data: None,\n            });\n        }\n        \"run\" =\u003e {\n            let id = crate::utils::get_millis().await;\n            let mut task: Task = Task {\n                id: id,\n                name: command.name,\n                command: command.args[0].clone(),\n                args: command.args[1..].to_vec(),\n                status: \"running\".to_string(),\n                pid: 0,\n                created_at: 0,\n                started_at: 0,\n                exited_at: 0,\n                stopped_at: 0,\n                laststart_at: 0,\n                exit_code: 100,\n                interval: id,\n                origin: 0,\n                timing: Vec::new(),\n            };\n\n            if command.options.contains_key(\"name\") {\n                let name = command.options.get(\"name\").unwrap();\n                match name {\n                    entity::Opt::Str(ref s) =\u003e {\n                        task.name = s.clone();\n                    }\n                    _ =\u003e {\n                        return Ok(entity::Response {\n                            code: 50000,\n                            msg: \"Arg 'name' must be a string\".to_string(),\n                            data: None,\n                        });\n                    }\n                }\n            } else {\n                task.name = get_id().await;\n            }\n\n            if command.options.contains_key(\"origin\") {\n                let origin = command.options.get(\"origin\").unwrap();\n                match origin {\n                    entity::Opt::U128(ref o) =\u003e {\n                        task.origin = *o;\n                    }\n                    _ =\u003e {\n                        return Ok(entity::Response {\n                            code: 50000,\n                            msg: \"Arg 'origin' must be a number\".to_string(),\n                            data: None,\n                        });\n                    }\n                }\n            } else {\n                task.origin = 0;\n            }\n\n            if command.options.contains_key(\"interval\") {\n                let interval = command.options.get(\"interval\").unwrap();\n                match interval {\n                    entity::Opt::U128(ref i) =\u003e {\n                        task.interval = *i;\n                        task.status = \"interval\".to_string();\n                    }\n                    _ =\u003e {\n                        return Ok(entity::Response {\n                            code: 50000,\n                            msg: \"Arg 'interval' must be a number\".to_string(),\n                            data: None,\n                        });\n                    }\n                }\n            } else {\n                task.interval = 0;\n            }\n\n            task.command = command.args[0].clone();\n            task.args = command.args[1..].to_vec();\n\n            let result = command::run::run_task(task).await?;\n            return Ok(result);\n        }\n        \"add\" =\u003e {\n            let id = crate::utils::get_millis().await;\n            let mut task: Task = Task {\n                id: id,\n                name: command.name,\n                command: command.args[0].clone(),\n                args: command.args[1..].to_vec(),\n                status: \"added\".to_string(),\n                pid: 0,\n                created_at: 0,\n                started_at: 0,\n                exited_at: 0,\n                stopped_at: 0,\n                laststart_at: 0,\n                exit_code: 100,\n                interval: 0,\n                origin: 0,\n                timing: Vec::new(),\n            };\n\n            if command.options.contains_key(\"name\") {\n                let name = command.options.get(\"name\").unwrap();\n                match name {\n                    entity::Opt::Str(ref s) =\u003e {\n                        task.name = s.clone();\n                    }\n                    _ =\u003e {\n                        return Ok(entity::Response {\n                            code: 50000,\n                            msg: \"Arg 'name' must be a string\".to_string(),\n                            data: None,\n                        });\n                    }\n                }\n            } else {\n                task.name = get_id().await;\n            }\n\n            if command.options.contains_key(\"origin\") {\n                let origin = command.options.get(\"origin\").unwrap();\n                match origin {\n                    entity::Opt::U128(ref o) =\u003e {\n                        task.origin = *o;\n                    }\n                    _ =\u003e {\n                        return Ok(entity::Response {\n                            code: 50000,\n                            msg: \"Arg 'origin' must be a number\".to_string(),\n                            data: None,\n                        });\n                    }\n                }\n            }\n\n            if command.options.contains_key(\"interval\") {\n                let interval = command.options.get(\"interval\").unwrap();\n                match interval {\n                    entity::Opt::U128(ref i) =\u003e {\n                        task.interval = *i;\n                        task.status = \"interval\".to_string();\n                    }\n                    _ =\u003e {\n                        return Ok(entity::Response {\n                            code: 50000,\n                            msg: \"Arg 'interval' must be a number\".to_string(),\n                            data: None,\n                        });\n                    }\n                }\n            }\n\n            if command.options.contains_key(\"timing\") {\n                let timing = command.options.get(\"timing\").unwrap();\n                match timing {\n                    entity::Opt::U128s(i) =\u003e {\n                        task.timing = i.clone();\n                        task.status = \"timing\".to_string();\n                    }\n                    _ =\u003e {\n                        return Ok(entity::Response {\n                            code: 50000,\n                            msg: \"Arg 'timing' must be a number array\".to_string(),\n                            data: None,\n                        });\n                    }\n                }\n            }\n\n            task.command = command.args[0].clone();\n            task.args = command.args[1..].to_vec();\n\n            let result = command::add::add_a_task(task).await?;\n            return Ok(result);\n        }\n        \"exit\" =\u003e {\n            let result = command::exit::exit_task(command).await;\n            match result {\n                Ok(res) =\u003e {\n                    return Ok(res);\n                }\n                Err(e) =\u003e {\n                    let res = entity::Response {\n                        code: 40000,\n                        msg: e.to_string(),\n                        data: None,\n                    };\n                    return Ok(res);\n                }\n            }\n        }\n        \"start\" =\u003e {\n            let result = command::start::start_task(command).await;\n            match result {\n                Ok(res) =\u003e {\n                    return Ok(res);\n                }\n                Err(e) =\u003e {\n                    let res = entity::Response {\n                        code: 40000,\n                        msg: e.to_string(),\n                        data: None,\n                    };\n                    return Ok(res);\n                }\n            }\n        }\n        \"restart\" =\u003e {\n            let result = command::restart::restart_task(command).await;\n            match result {\n                Ok(res) =\u003e {\n                    return Ok(res);\n                }\n                Err(e) =\u003e {\n                    let res = entity::Response {\n                        code: 40000,\n                        msg: e.to_string(),\n                        data: None,\n                    };\n                    return Ok(res);\n                }\n            }\n        }\n        \"stop\" =\u003e {\n            let result = command::stop::stop_task(command).await;\n            match result {\n                Ok(res) =\u003e {\n                    return Ok(res);\n                }\n                Err(e) =\u003e {\n                    let res = entity::Response {\n                        code: 40000,\n                        msg: e.to_string(),\n                        data: None,\n                    };\n                    return Ok(res);\n                }\n            }\n        }\n        \"pause\" =\u003e {\n            let result = command::pause::pause_task(command).await;\n            match result {\n                Ok(res) =\u003e {\n                    return Ok(res);\n                }\n                Err(e) =\u003e {\n                    let res = entity::Response {\n                        code: 40000,\n                        msg: e.to_string(),\n                        data: None,\n                    };\n                    return Ok(res);\n                }\n            }\n        }\n        \"resume\" =\u003e {\n            let result = command::resume::resume_task(command).await;\n            match result {\n                Ok(res) =\u003e {\n                    return Ok(res);\n                }\n                Err(e) =\u003e {\n                    let res = entity::Response {\n                        code: 40000,\n                        msg: e.to_string(),\n                        data: None,\n                    };\n                    return Ok(res);\n                }\n            }\n        }\n        \"list\" =\u003e {\n            let result = command::list::list_tasks(command).await;\n            match result {\n                Ok(res) =\u003e {\n                    return Ok(res);\n                }\n                Err(e) =\u003e {\n                    let res = entity::Response {\n                        code: 40000,\n                        msg: e.to_string(),\n                        data: None,\n                    };\n                    return Ok(res);\n                }\n            }\n        }\n        _ =\u003e Ok(entity::Response {\n            code: 40000,\n            msg: format!(\"unknown command: {:?}\", command),\n            data: None,\n        }),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","entity.rs"],"content":"use std::collections::HashMap;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Task {\n    pub id: u128,\n    pub name: String,\n    pub command: String,\n    pub args: Vec\u003cString\u003e,\n    pub status: String,\n    pub pid: u32,\n    pub created_at: u128,\n    pub started_at: u128,\n    pub exited_at: u128,\n    pub stopped_at: u128,\n    pub laststart_at: u128,\n    pub exit_code: u32,\n    pub interval: u128,\n    pub origin: u128,\n    pub timing: Vec\u003cu128\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub enum Opt {\n    U128(u128),\n    U128s(Vec\u003cu128\u003e),\n    U32(u32),\n    Str(String),\n    None,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Command {\n    pub name: String,\n    pub options: HashMap\u003cString, Opt\u003e,\n    pub args: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Request {\n    pub name: String,\n    pub command: Command,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub enum Data {\n    TaskList(Vec\u003cTask\u003e),\n    None,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Response {\n    pub code: u32,\n    pub msg: String,\n    pub data: Option\u003cData\u003e,\n}\n\nimpl Response {\n    pub fn new(code: u32, msg: String, data: Option\u003cData\u003e) -\u003e Self {\n        Self { code, msg, data }\n    }\n\n    pub fn ok\u003cT: ToString\u003e(msg: T) -\u003e Self {\n        Self {\n            code: 10000,\n            msg: msg.to_string(),\n            data: None,\n        }\n    }\n\n    pub fn data\u003cT: ToString\u003e(msg: T, data: Option\u003cData\u003e) -\u003e Self {\n        Self {\n            code: 10000,\n            msg: msg.to_string(),\n            data: data,\n        }\n    }\n\n    pub fn err\u003cT: ToString\u003e(msg: T) -\u003e Self {\n        Self {\n            code: 40000,\n            msg: msg.to_string(),\n            data: None,\n        }\n    }\n\n    pub fn f\u003cT: ToString\u003e(msg: T) -\u003e Self {\n        Self {\n            code: 40000,\n            msg: msg.to_string(),\n            data: None,\n        }\n    }\n}\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","ahri","watchmen","daemon","src","lib.rs"],"content":"pub mod command;\npub mod entity;\npub mod macros;\npub mod monitor;\npub mod socket;\npub mod utils;\n\npub mod global {\n    use std::{error::Error, fs::File, path::Path};\n\n    use lazy_static::lazy_static;\n    use serde_json;\n    use tokio::sync::Mutex;\n\n    use crate::{\n        command::start::{self},\n        entity::Task,\n    };\n\n    lazy_static! {\n        static ref TASKS: Mutex\u003cVec\u003cTask\u003e\u003e = Mutex::new(Vec::new());\n    }\n\n    pub async fn save_tasks(tasks: Vec\u003cTask\u003e) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let args: Vec\u003cString\u003e = std::env::args().collect();\n        if args.len() \u003c 4 {\n            return Err(\"Command line args error\".into());\n        }\n        let home_path = args[2].clone();\n\n        let path = Path::new(\u0026home_path);\n        let path = path.join(\"tasks.json\");\n        match File::create(path) {\n            Ok(f) =\u003e match serde_json::to_writer_pretty(f, \u0026tasks) {\n                _ =\u003e Ok(()),\n            },\n            Err(_) =\u003e Ok(()),\n        }\n    }\n\n    pub async fn load_tasks(home_path: String) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let path = Path::new(\u0026home_path);\n        let path = path.join(\"tasks.json\");\n\n        if path.exists() \u0026\u0026 path.is_file() {\n            let f = File::open(path).unwrap();\n            let data: Vec\u003cTask\u003e = serde_json::from_reader(f).unwrap();\n            let mut tasks = TASKS.lock().await;\n            *tasks = data.clone();\n\n            // 释放锁, 启动 task 时需要更改 task 状态, 需要获取锁\n            drop(tasks);\n\n            for task in data {\n                if task.status == \"running\" {\n                    match start::start_task_by_task(task.clone()).await {\n                        Ok(_) =\u003e {}\n                        Err(_) =\u003e {}\n                    };\n                }\n            }\n        }\n        Ok(())\n    }\n\n    pub async fn check_exists(name: String) -\u003e Result\u003cbool, Box\u003cdyn Error\u003e\u003e {\n        let tasks = get_all_tasks().await?;\n        for task in tasks.iter() {\n            if task.name == name {\n                return Ok(true);\n            }\n        }\n        Ok(false)\n    }\n\n    pub async fn get_task_by_id(id: u128) -\u003e Result\u003cTask, Box\u003cdyn Error\u003e\u003e {\n        let tasks = get_all_tasks().await?;\n        for task in tasks.iter() {\n            if task.id == id {\n                return Ok(task.clone());\n            }\n        }\n        let err = format!(\"Task id '{}' not found\", id);\n        return Err(err.into());\n    }\n\n    pub async fn get_task_by_name(name: String) -\u003e Result\u003cTask, Box\u003cdyn Error\u003e\u003e {\n        let tasks = get_all_tasks().await?;\n        for task in tasks.iter() {\n            if task.name == name {\n                return Ok(task.clone());\n            }\n        }\n        let err = format!(\"Task named '{}' not found\", name);\n        return Err(err.into());\n    }\n\n    pub async fn get_task_by_pid(pid: u32) -\u003e Result\u003cTask, Box\u003cdyn Error\u003e\u003e {\n        let tasks = TASKS.lock().await;\n        for task in tasks.iter() {\n            if task.pid == pid {\n                return Ok(task.clone());\n            }\n        }\n        let err = format!(\"Task pid is '{}' not found\", pid);\n        return Err(err.into());\n    }\n\n    pub async fn get_all_tasks() -\u003e Result\u003cVec\u003cTask\u003e, Box\u003cdyn Error\u003e\u003e {\n        let tasks = TASKS.lock().await;\n        Ok(tasks.to_vec())\n    }\n\n    pub async fn remove_task_by_id(id: u128) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let mut index = 0;\n        for (i, task) in tasks.iter().enumerate() {\n            if task.id == id {\n                index = i;\n                break;\n            }\n        }\n        tasks.remove(index);\n        save_tasks(tasks.clone()).await?;\n        Ok(())\n    }\n\n    pub async fn remove_task_by_name(name: String) -\u003e Result\u003cOption\u003cTask\u003e, Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.name == name);\n        if let Some(pos) = pos {\n            let res = tasks.remove(pos);\n            save_tasks(tasks.clone()).await?;\n            return Ok(Some(res));\n        }\n        Ok(None)\n    }\n\n    pub async fn remove_task_by_pid(pid: u32) -\u003e Result\u003cOption\u003cTask\u003e, Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.pid == pid);\n        if let Some(pos) = pos {\n            let res = tasks.remove(pos);\n            save_tasks(tasks.clone()).await?;\n            return Ok(Some(res));\n        }\n        Ok(None)\n    }\n\n    pub async fn add_task(task: Task) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let timestamp = crate::utils::get_millis().await;\n        let task = Task {\n            created_at: timestamp,\n            ..task\n        };\n        tasks.push(task);\n        save_tasks(tasks.clone()).await?;\n        Ok(())\n    }\n\n    pub async fn update_pid_by_name(name: String, pid: u32) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.name == name);\n        if let Some(pos) = pos {\n            tasks[pos].pid = pid;\n            save_tasks(tasks.clone()).await?;\n        }\n        Ok(())\n    }\n\n    pub async fn update_status_by_name(name: String, status: String) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.name == name);\n        if let Some(pos) = pos {\n            tasks[pos].status = status;\n            save_tasks(tasks.clone()).await?;\n        }\n        Ok(())\n    }\n\n    pub async fn update_started_at_by_id(id: u128, started_at: u128) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.id == id);\n        if let Some(pos) = pos {\n            tasks[pos].started_at = started_at;\n            save_tasks(tasks.clone()).await?;\n        }\n        Ok(())\n    }\n\n    pub async fn update_exited_at_by_id(id: u128, exited_at: u128) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.id == id);\n        if let Some(pos) = pos {\n            tasks[pos].exited_at = exited_at;\n            save_tasks(tasks.clone()).await?;\n        }\n        Ok(())\n    }\n\n    pub async fn update_stopped_at_by_id(id: u128, stopped_at: u128) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.id == id);\n        if let Some(pos) = pos {\n            tasks[pos].stopped_at = stopped_at;\n            save_tasks(tasks.clone()).await?;\n        }\n        Ok(())\n    }\n\n    pub async fn update_laststart_at_by_id(\n        id: u128,\n        laststart_at: u128,\n    ) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.id == id);\n        if let Some(pos) = pos {\n            tasks[pos].laststart_at = laststart_at;\n            save_tasks(tasks.clone()).await?;\n        }\n        Ok(())\n    }\n\n    pub async fn update_exit_code_by_name(\n        name: String,\n        exit_code: u32,\n    ) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.name == name);\n        if let Some(pos) = pos {\n            tasks[pos].exit_code = exit_code;\n            save_tasks(tasks.clone()).await?;\n        }\n        Ok(())\n    }\n}\n\npub mod constants {\n    pub enum ExitCode {\n        SUCCESS = 0,\n        ERROR = 255,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","macros.rs"],"content":"#[macro_export]\nmacro_rules! info {\n    ($($arg:tt)*) =\u003e {\n        let dft = Local::now().to_string();\n        println!(\"[INFO]\\t{}\\t{}\", dft, format_args!($($arg)*));\n    };\n}\n\n#[macro_export]\nmacro_rules! error {\n    ($($arg:tt)*) =\u003e {\n        let dft = Local::now().to_string();\n        eprintln!(\"[ERROR]\\t{}\\t{}\", dft, format_args!($($arg)*));\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","main.rs"],"content":"use std::{error::Error, fs::remove_file, path::Path, process::exit};\nuse tokio::sync::mpsc;\n\nuse daemon::monitor::run_monitor;\nuse daemon::socket::run_socket;\n\nuse logger::{self, log};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    let args: Vec\u003cString\u003e = std::env::args().collect();\n    // args[0]: daemon\n    // args[1]: sock_path\n    // args[2]: home_path\n    // args[3]: stdout_path\n    if args.len() \u003c 4 {\n        eprintln!(\"Exit code: 255 =\u003e Missing path argument.\");\n        exit(255);\n    }\n\n    let mut l = logger::Logger::new(\n        logger::Level::Info,\n        String::from(\"[L]\\t[T]\\t[M]\"),\n        String::from(args[2].clone()),\n        String::from(\"daemon\"),\n        1024 * 1024 * 10,\n    );\n\n    let home_path = args[2].clone();\n\n    // 加载上次运行的任务\n    let tasks_result = daemon::global::load_tasks(home_path.clone()).await;\n    if tasks_result.is_err() {\n        log!(l, error, \"Exit code: 254 =\u003e {}\", tasks_result.err().unwrap());\n        exit(254);\n    }\n    let mut ll = l.clone();\n    let monitor = tokio::spawn(async move {\n        match run_monitor(home_path).await {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                log!(ll, error, \"Exit code: 253 =\u003e {}\", e);\n                exit(253);\n            }\n        }\n    });\n\n    let path = args[1].clone();\n\n    // 新线程运行 run_socket\n    let p1 = path.clone();\n    let socket = tokio::spawn(async move {\n        run_socket(\u0026p1).await.unwrap();\n    });\n\n    // 协程间通信 / channel, 监听 ctrl c 和 ctrl d 信号 / listen ctrl-c and ctrl-d signal\n    let (tx, mut rx) = mpsc::channel::\u003ci32\u003e(12);\n\n    let tx1 = tx.clone(); // 监听到 ctrl c 通信管道\n    let tx2 = tx.clone(); // 监听到 ctrl d 通信管道\n\n    // ctrl c 停止运行 / terminate on ctrl-c\n    let signal1 = tokio::spawn(async move {\n        tokio::signal::ctrl_c().await.unwrap();\n        tx1.send(9).await.unwrap();\n    });\n\n    // ctrl d 停止运行 / terminate on ctrl-d\n    let signal2 = tokio::spawn(async move {\n        tokio::signal::unix::signal(tokio::signal::unix::SignalKind::terminate())\n            .unwrap()\n            .recv()\n            .await;\n        tx2.send(15).await.unwrap();\n    });\n\n    // 等待停止信号 / wait for stop signal\n    let res = rx.recv().await;\n\n    signal1.abort();\n    signal2.abort();\n    monitor.abort();\n    socket.abort();\n\n    // 删除 sock 文件 / remove sock file\n    let p2 = path.clone();\n    let sock_path = Path::new(\u0026p2);\n    remove_file(sock_path).unwrap_or_default();\n\n    if let Some(code) = res {\n        log!(l, info, \"Exit code: {} =\u003e exited\", code);\n        exit(code);\n    } else {\n        log!(l, info, \"Exit code: 0 =\u003e exited\");\n        exit(0);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use logger;\n\n    #[test]\n    fn test() {\n        let mut log = logger::Logger::new(\n            logger::Level::Info,\n            String::from(\"[T]\\t[L]\\t[M]\"),\n            String::from(\"/tmp/watchmen/\"),\n            String::from(\"daemon\"),\n            1024,\n        );\n\n        log.info(\"test\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","monitor.rs"],"content":"use chrono::prelude::{DateTime, Local};\nuse std::{env, path::Path, process::Stdio, time::Duration};\nuse tokio::{\n    process::{Child, Command},\n    time,\n};\n\nuse crate::{\n    entity,\n    global::{get_all_tasks, update_laststart_at_by_id},\n};\n\npub async fn rerun_tasks(home_path: String) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let tasks = get_all_tasks().await?;\n    for task in tasks {\n        let time: DateTime\u003cLocal\u003e = Local::now();\n        let now = time.timestamp_millis() as u128;\n\n        if task.status == \"interval\" \u0026\u0026 now \u003e= task.origin {\n            if now - task.laststart_at \u003c task.interval {\n                continue;\n            }\n\n            // 声明指向文件的 stdout\n            let path = Path::new(\u0026home_path);\n            let path = path.join(\"stdout\");\n            let path = path.join(format!(\"{}.log\", task.name));\n\n            // 创建或追加文件\n            let file = std::fs::OpenOptions::new()\n                .create(true)\n                .append(true)\n                .open(path)?;\n            let stdout = Stdio::from(file);\n\n            crate::info!(\"TASK\\tEXECUTE\\t{:?}\", task);\n\n            // 获取环境变量 PATH\n            let env_path = env::var(\"PATH\")?;\n            let mut child: Child = Command::new(\u0026task.command)\n                .args(\u0026task.args)\n                .env(\"PATH\", env_path)\n                .stdin(Stdio::null())\n                .stdout(stdout)\n                .stderr(Stdio::null())\n                .spawn()?;\n\n            let result = child.id();\n            if result.is_some() {\n                update_laststart_at_by_id(task.id, now).await?;\n                tokio::spawn(async move {\n                    let s = child.wait().await.unwrap();\n                    let exit_code = s.code().unwrap_or(-1);\n                    crate::info!(\"TASK\\tFINISH\\t{}\\t{:?}\", exit_code, task);\n                });\n            }\n        }\n    }\n    Ok(())\n}\n\npub async fn run_monitor(\n    home_path: String,\n) -\u003e Result\u003centity::Response, Box\u003cdyn std::error::Error\u003e\u003e {\n    let mut interval = time::interval(Duration::from_secs(2));\n    loop {\n        match rerun_tasks(home_path.clone()).await {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                crate::error!(\"Monitor tasks error: {}\", e);\n            }\n        }\n        interval.tick().await;\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","socket.rs"],"content":"use chrono::Local;\nuse std::{error::Error, fs::remove_file, path::Path, process::exit};\nuse tokio::{\n    io::{AsyncReadExt, AsyncWriteExt},\n    net::{UnixListener, UnixStream},\n};\n\nuse crate::{command, entity};\n\nasync fn handle_connection(mut stream: UnixStream) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    let (mut reader, mut writer) = stream.split();\n    let mut buf: [u8; 1024] = [0; 1024];\n    let n = reader.read(\u0026mut buf).await?;\n\n    let req: entity::Request = serde_json::from_slice(\u0026buf[..n])?;\n\n    let res = command::handle_exec(req.command).await?;\n\n    writer.write_all(\u0026serde_json::to_vec(\u0026res)?).await?;\n\n    if res.code == 10 {\n        let args: Vec\u003cString\u003e = std::env::args().collect();\n        let path = args[1].clone();\n        let sock_path = Path::new(\u0026path);\n        remove_file(sock_path).unwrap_or_default();\n        exit(0);\n    }\n    Ok(())\n}\n\npub async fn run_socket(path: \u0026String) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    let sock_path = Path::new(path);\n    remove_file(sock_path).unwrap_or_default();\n\n    // 创建监听器 / create a listener\n    let listener = UnixListener::bind(path);\n\n    match listener {\n        Ok(listener) =\u003e {\n            crate::info!(\"Listening\\t{:?}\", listener.local_addr().unwrap());\n\n            loop {\n                // 等待连接 / wait connection\n                match listener.accept().await {\n                    Ok((stream, _addr)) =\u003e {\n                        // 处理连接 / handle connection\n                        tokio::spawn(async move {\n                            if let Err(e) = handle_connection(stream).await {\n                                eprintln!(\"failed to process connection: {}\", e);\n                            }\n                        });\n                    }\n                    Err(e) =\u003e {\n                        eprintln!(\"failed to accept socket; error = {:?}\", e);\n                    }\n                }\n            }\n        }\n        Err(e) =\u003e {\n            eprintln!(\"{}: {}\", Local::now(), e);\n            exit(1);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","utils.rs"],"content":"use nanoid::nanoid;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\npub async fn get_id() -\u003e String {\n    let alphabet: [char; 62] = [\n        '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\n        'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',\n        'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    ];\n    nanoid!(10, \u0026alphabet)\n}\n\npub async fn get_millis() -\u003e u128 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .unwrap()\n        .as_millis()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","guard","src","main.rs"],"content":"use std::{\n    env,\n    error::Error,\n    fs::remove_file,\n    io::Write,\n    path::Path,\n    process::{exit, Stdio},\n};\n\nuse tokio::process::Command;\n\n#[tokio::main]\nasync fn main() {\n    let args: Vec\u003cString\u003e = env::args().collect();\n    if args.len() \u003c 4 {\n        eprintln!(\"Missing path argument.\");\n        exit(0);\n    }\n\n    let valid_args = args[1..].to_vec();\n\n    loop {\n        match start_daemon(\u0026valid_args).await {\n            Ok(res_code) =\u003e match res_code {\n                10000 =\u003e {\n                    println!(\"Daemon terminated. {}\", res_code);\n                    exit(0);\n                }\n                50000 =\u003e {\n                    println!(\"Unexpected termination of program. {}\", res_code);\n                }\n                _ =\u003e {\n                    eprintln!(\"Unexpected program error. {}\", res_code);\n                }\n            },\n            Err(err) =\u003e {\n                eprintln!(\"{}\", err);\n                break;\n            }\n        }\n    }\n}\n\nasync fn start_daemon(args: \u0026[String]) -\u003e Result\u003ci32, Box\u003cdyn Error\u003e\u003e {\n    let now = chrono::Local::now().format(\"%Y%m%d\").to_string();\n    let path = Path::new(\u0026args[1]);\n    let path_daemon_stdout = path.clone().join(format!(\"daemon_stdout_{}.log\", now));\n    let path_daemon_stderr = path.clone().join(format!(\"daemon_stderr_{}.log\", now));\n    let file_stdout = std::fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(path_daemon_stdout.clone())?;\n    let file_stderr = std::fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(path_daemon_stderr.clone())?;\n    let stdout = Stdio::from(file_stdout);\n    let stderr = Stdio::from(file_stderr);\n\n    let path_daemon = std::env::current_dir()?.join(\"daemon\");\n    // 子进程\n    let mut child = Command::new(path_daemon)\n        .args(args)\n        .stdout(stdout)\n        .stderr(stderr)\n        .spawn()?;\n\n    let result = child.id();\n\n    match result {\n        Some(pid) =\u003e {\n            // 保存 pid\n            let path_watchmen = path.join(\"daemon.pid\");\n            // 创建文件\n            let mut file = std::fs::File::create(path_watchmen.clone())?;\n            // 写入 pid\n            file.write_all(pid.to_string().as_bytes())?;\n\n            let res = child.wait().await.unwrap();\n            remove_file(path_watchmen).unwrap_or_default();\n\n            if res.success() {\n                let path_guard = path.join(\"guard.pid\");\n                remove_file(path_guard).unwrap_or_default();\n                return Ok(10000);\n            } else {\n                return Ok(50000);\n            }\n        }\n        None =\u003e Ok(-1),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","library","logger","src","lib.rs"],"content":"use std::{fs::File, io::Write};\n\n#[derive(Clone)]\npub enum Level {\n    Debug = 0,\n    Info = 1,\n    Warn = 2,\n    Error = 3,\n}\n\n#[derive(Clone)]\npub struct Logger {\n    level: Level,\n    format: String,\n    path: String,\n    filename: String,\n    max_size: u64,\n}\n\nimpl Logger {\n    pub fn new(\n        level: Level,\n        format: String,\n        path: String,\n        filename: String,\n        max_size: u64,\n    ) -\u003e Self {\n        Self {\n            level,\n            format,\n            path,\n            filename,\n            max_size,\n        }\n    }\n\n    fn f(\u0026mut self) -\u003e File {\n        let file: File;\n        let mut index = 1;\n        loop {\n            let log_file_name = format!(\n                \"{}_{}_{}.log\",\n                self.filename,\n                chrono::Local::now().format(\"%Y%m%d\").to_string(),\n                index\n            );\n            let file_path = std::path::Path::new(\u0026self.path).join(log_file_name);\n            if file_path.exists() {\n                let file_size = std::fs::metadata(file_path.clone()).unwrap().len();\n                if file_size \u003e= self.max_size {\n                    index += 1;\n                    continue;\n                } else {\n                    file = std::fs::OpenOptions::new()\n                        .create(true)\n                        .append(true)\n                        .open(file_path.clone())\n                        .unwrap();\n                    break;\n                }\n            } else {\n                file = std::fs::OpenOptions::new()\n                    .create(true)\n                    .append(true)\n                    .open(file_path.clone())\n                    .unwrap();\n                break;\n            }\n        }\n        return file;\n    }\n\n    fn w(\u0026mut self, msg: \u0026str, level: Level) {\n        let mut file = self.f();\n\n        /*\n         * [T] - 时间\n         * [L] - 日志级别\n         * [M] - 日志内容\n         */\n        let t = chrono::Local::now().format(\"[%Y-%m-%d %H:%M:%S]\");\n        let l = match level {\n            Level::Debug =\u003e \"[Debug]\",\n            Level::Info =\u003e \"[Info]\",\n            Level::Warn =\u003e \"[Warn]\",\n            Level::Error =\u003e \"[Error]\",\n        };\n        let message: String = self\n            .format\n            .replace(\"[T]\", \u0026t.to_string())\n            .replace(\"[L]\", l)\n            .replace(\"[M]\", \u0026msg);\n\n        let message = format!(\"{}\\n\", message);\n\n        file.write_all(message.as_bytes()).unwrap();\n    }\n\n    pub fn debug(\u0026mut self, msg: \u0026str) {\n        self.w(msg, Level::Debug);\n    }\n\n    pub fn info(\u0026mut self, msg: \u0026str) {\n        match self.level {\n            Level::Info =\u003e self.w(msg, Level::Info),\n            Level::Warn =\u003e self.w(msg, Level::Info),\n            Level::Error =\u003e self.w(msg, Level::Info),\n            _ =\u003e return,\n        }\n    }\n\n    pub fn warn(\u0026mut self, msg: \u0026str) {\n        match self.level {\n            Level::Warn =\u003e self.w(msg, Level::Warn),\n            Level::Error =\u003e self.w(msg, Level::Warn),\n            _ =\u003e return,\n        }\n    }\n\n    pub fn error(\u0026mut self, msg: \u0026str) {\n        match self.level {\n            Level::Error =\u003e self.w(msg, Level::Error),\n            _ =\u003e return,\n        }\n    }\n}\n\n#[macro_export]\nmacro_rules! log {\n    ($logger:ident, $level:ident, $($arg:tt)*) =\u003e {\n        $logger.$level(\u0026format!($($arg)*));\n    };\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test() {\n        let mut logger = Logger::new(\n            Level::Debug,\n            \"[T] [L] [M]\".to_string(),\n            \"/tmp/watchmen/\".to_string(),\n            \"test\".to_string(),\n            1024 * 1024 * 10,\n        );\n        log!(logger, debug, \"debug{}\", 1);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","plugins","plugin","src","lib.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[repr(C)]\npub struct Task {\n    pub id: u128,\n    pub name: String,\n    pub command: String,\n    pub args: Vec\u003cString\u003e,\n    pub status: String,\n    pub pid: u32,\n    pub created_at: u128,\n    pub started_at: u128,\n    pub exited_at: u128,\n    pub stopped_at: u128,\n    pub laststart_at: u128,\n    pub exit_code: u32,\n    pub interval: u128,\n    pub origin: u128,\n    pub timing: Vec\u003cu128\u003e,\n}\n\n#[no_mangle]\npub async extern \"C\" fn func_plugin(t: i32) -\u003e bool {\n    print!(\"PRINT FROM PLUGIN: {:?}\", t);\n    false\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","add.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst ADD_HELP: \u0026str = r#\"Usage: watchmen add [OPTION...] ...\n    -h, --help          display this help of 'add' command\n\n    -n, --name          task name, default is a random string\n\n    -o, --origin        recurring task start time\n                        format: YYYYMMDD.HHMMSS | YYYYMMDD | MMDD | MMDD.HHMMSS | HHMMSS\n                        example: 20201231.235959 | 20201231 | 1231 | 1231.235959 | 235959\n\n    -i, --interval      recurring task interval\n                        format: 1d2h3m4s5 | 3m4s5 | 4s5 | 5 ...\n\n    -t, --timing        scheduled Tasks\n                        format: split by ',' YYYYMMDD.HHMMSS | YYYYMMDD | MMDD | MMDD.HHMMSS | HHMMSS\n                        example: 20210101.000000,20210102.000000,20210103\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(ADD_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(ADD_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    if args[1].starts_with(\"-\") {\n                        return Ok(entity::Response::err(format!(\n                            \"Value of '{}' connot start with '-'\",\n                            args[0]\n                        )));\n                    }\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-o\" || args[0] == \"--origin\" {\n                    let mut input = args[1].clone();\n\n                    if !input.contains(\".\") {\n                        input = match input.len() {\n                            4 =\u003e {\n                                // current year\n                                let year = chrono::Local::now().format(\"%Y\").to_string();\n                                format!(\"{}{}.000000\", year, input)\n                            }\n                            8 =\u003e format!(\"{}.000000\", input),\n                            6 =\u003e {\n                                let date = chrono::Local::now().format(\"%Y%m%d\").to_string();\n                                format!(\"{}.{}\", date, input)\n                            }\n                            _ =\u003e {\n                                println!(\"Invalid timestamp: {}\", input);\n                                return Ok(entity::Response::f(format!(\n                                    \"Arg '{}' must be a number\",\n                                    args[0]\n                                )));\n                            }\n                        };\n                    }\n                    if input.len() == 11 {\n                        let year = chrono::Local::now().format(\"%Y\").to_string();\n                        input = format!(\"{}{}\", year, input);\n                    }\n                    let timestamp = chrono::NaiveDateTime::parse_from_str(\u0026input, \"%Y%m%d.%H%M%S\")\n                        .unwrap()\n                        .timestamp_millis() as u128;\n                    options.insert(\"pid\".to_string(), Opt::U128(timestamp));\n                } else if args[0] == \"-i\" || args[0] == \"--interval\" {\n                    let mut ms: u128 = 0;\n                    let mut num: u128 = 0;\n\n                    for c in args[1].chars() {\n                        if c.is_numeric() {\n                            num = num * 10 + c.to_digit(10).unwrap() as u128;\n                        } else {\n                            match c {\n                                'd' =\u003e {\n                                    ms += num * 24 * 60 * 60 * 1000;\n                                }\n                                'h' =\u003e {\n                                    ms += num * 60 * 60 * 1000;\n                                }\n                                'm' =\u003e {\n                                    ms += num * 60 * 1000;\n                                }\n                                's' =\u003e {\n                                    ms += num * 1000;\n                                }\n                                _ =\u003e {\n                                    return Ok(entity::Response::f(format!(\n                                        \"Arg '{}' value invalid unit\",\n                                        args[0]\n                                    )));\n                                }\n                            }\n                            num = 0;\n                        }\n                    }\n                    if num \u003e 999 {\n                        return Ok(entity::Response::f(format!(\n                            \"Arg '{}' value 'ms' must less 1000\",\n                            args[0]\n                        )));\n                    }\n                    ms += num;\n                    options.insert(\"interval\".to_string(), Opt::U128(ms));\n                } else if args[0] == \"-t\" || args[0] == \"--timing\" {\n                    let inputs = args[1].clone();\n                    let mut timestamps: Vec\u003cu128\u003e = Vec::new();\n                    for ipt in inputs.split(\",\") {\n                        let mut input = ipt.to_string();\n                        if !input.contains(\".\") {\n                            input = match input.len() {\n                                4 =\u003e {\n                                    // current year\n                                    let year = chrono::Local::now().format(\"%Y\").to_string();\n                                    format!(\"{}{}.000000\", year, input)\n                                }\n                                8 =\u003e format!(\"{}.000000\", input),\n                                6 =\u003e {\n                                    let date = chrono::Local::now().format(\"%Y%m%d\").to_string();\n                                    format!(\"{}.{}\", date, input)\n                                }\n                                _ =\u003e {\n                                    println!(\"Invalid timestamp: {}\", input);\n                                    return Ok(entity::Response::f(format!(\n                                        \"Arg '{}' must be a number\",\n                                        args[0]\n                                    )));\n                                }\n                            };\n                        }\n                        if input.len() == 11 {\n                            let year = chrono::Local::now().format(\"%Y\").to_string();\n                            input = format!(\"{}{}\", year, input);\n                        }\n                        let timestamp =\n                            chrono::NaiveDateTime::parse_from_str(\u0026input, \"%Y%m%d.%H%M%S\")\n                                .unwrap()\n                                .timestamp_millis() as u128;\n                        timestamps.push(timestamp);\n                    }\n                    options.insert(\"timing\".to_string(), Opt::U128s(timestamps));\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n            let req = entity::Request {\n                name: \"add\".to_string(),\n                command: entity::Command {\n                    name: \"add\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","exit.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst EXIT_HELP: \u0026str = r#\"Usage: watchmen [exit|rm|drop] [OPTION...] ...\n    -h, --help      display this help of 'exit' | 'rm' | 'drop' command\n\n    -i, --id        task id\n    -n, --name      task name\n    -p, --pid       task pid\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(EXIT_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(EXIT_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-p\" || args[0] == \"--pid\" {\n                    let pid = args[1].parse::\u003cu32\u003e();\n                    match pid {\n                        Ok(p) =\u003e {\n                            options.insert(\"pid\".to_string(), Opt::U32(p));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else if args[0] == \"-i\" || args[0] == \"--id\" {\n                    let id = args[1].parse::\u003cu128\u003e();\n                    match id {\n                        Ok(i) =\u003e {\n                            options.insert(\"id\".to_string(), Opt::U128(i));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n\n            let req = entity::Request {\n                name: \"exit\".to_string(),\n                command: entity::Command {\n                    name: \"exit\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","list.rs"],"content":"use chrono::{Local, TimeZone};\nuse colored::Colorize;\nuse std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt, Task},\n    socket,\n};\n\nconst LIST_HELP: \u0026str = r#\"Usage: watchmen list [OPTION...] ...\n    -h, --help      display this help of 'list' command\n\n    -n, --name      tasks name with regular expression\n    -s, --status    task status\n    -p, --pid       task pid\n\n    -m, --more      show more details\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    let mut more = false;\n    if len == 1 {\n        if args[0] == \"-h\" || args[0] == \"--help\" {\n            return Ok(entity::Response::ok(LIST_HELP));\n        } else if args[0] == \"-m\" || args[0] == \"--more\" {\n            more = true;\n        }\n    }\n    let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n    let mut args: Vec\u003cString\u003e = args.to_vec();\n    while args.len() \u003e 1 {\n        if args[0] == \"-n\" || args[0] == \"--name\" {\n            options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n            args.remove(0);\n            args.remove(0);\n        } else if args[0] == \"-s\" || args[0] == \"--status\" {\n            options.insert(\"status\".to_string(), Opt::Str(args[1].clone()));\n            args.remove(0);\n            args.remove(0);\n        } else if args[0] == \"-p\" || args[0] == \"--pid\" {\n            let pid = args[1].parse::\u003cu32\u003e();\n            match pid {\n                Ok(p) =\u003e {\n                    options.insert(\"pid\".to_string(), Opt::U32(p));\n                }\n                Err(_) =\u003e {\n                    return Ok(entity::Response::f(format!(\n                        \"Arg '{}' must be a number\",\n                        args[0]\n                    )));\n                }\n            }\n            args.remove(0);\n            args.remove(0);\n        } else if args[0] == \"-m\" || args[0] == \"--more\" {\n            more = true;\n            args.remove(0);\n        } else {\n            break;\n        }\n    }\n\n    let req = entity::Request {\n        name: \"list\".to_string(),\n        command: entity::Command {\n            name: \"list\".to_string(),\n            options: options,\n            args: args,\n        },\n    };\n    let res = socket::request(\u0026req, home_path).await?;\n    if let Some(data) = res.data {\n        match data {\n            entity::Data::TaskList(tasks) =\u003e print_format(tasks, more).await,\n            _ =\u003e {}\n        }\n    }\n    Ok(entity::Response::ok(\"list success\"))\n}\n\nasync fn print_format(res: Vec\u003cTask\u003e, more: bool) {\n    let sum_all = res.len();\n    let len_id = res\n        .iter()\n        .map(|x| x.id.to_string().len())\n        .max()\n        .unwrap_or_else(|| 0);\n    let len_name = res.iter().map(|x| x.name.len()).max().unwrap_or_else(|| 0);\n    let len_status = res\n        .iter()\n        .map(|x| x.status.len())\n        .max()\n        .unwrap_or_else(|| 0);\n    let len_pid = res\n        .iter()\n        .map(|x| x.pid.to_string().len())\n        .max()\n        .unwrap_or_else(|| 0);\n    let len_created_at = 19;\n    let len_started_at = 19;\n    let len_exited_at = 19;\n    let len_stopped_at = 19;\n    let len_exit_code = 5;\n\n    let title_id = \"ID\".bold();\n    let len_id = if len_id \u003e title_id.len() {\n        len_id\n    } else {\n        title_id.len()\n    };\n    let title_name = \"NAME\".bold();\n    let len_name = if len_name \u003e title_name.len() {\n        len_name\n    } else {\n        title_name.len()\n    };\n    let title_status = \"·STATUS\".bold();\n    let len_status = if len_status \u003e title_status.len() {\n        len_status\n    } else {\n        title_status.len()\n    };\n    let title_pid = \"PID\".bold();\n    let len_pid = if len_pid \u003e title_pid.len() {\n        len_pid\n    } else {\n        title_pid.len()\n    };\n    let title_created_at = \"CREATED_AT\".bold();\n    let len_created_at = if len_created_at \u003e title_created_at.len() {\n        len_created_at\n    } else {\n        title_created_at.len()\n    };\n    let title_started_at = \"STARTED_AT\".bold();\n    let len_started_at = if len_started_at \u003e title_started_at.len() {\n        len_started_at\n    } else {\n        title_started_at.len()\n    };\n    let title_exited_at = \"EXITED_AT\".bold();\n    let len_exited_at = if len_exited_at \u003e title_exited_at.len() {\n        len_exited_at\n    } else {\n        title_exited_at.len()\n    };\n    let title_stopped_at = \"STOPPED_AT\".bold();\n    let len_stopped_at = if len_stopped_at \u003e title_stopped_at.len() {\n        len_stopped_at\n    } else {\n        title_stopped_at.len()\n    };\n    let title_exit_code = \"EXIT_CODE\".bold();\n    let len_exit_code = if len_exit_code \u003e title_exit_code.len() {\n        len_exit_code\n    } else {\n        title_exit_code.len()\n    };\n\n    if more {\n        let len_sum = len_id\n            + len_name\n            + len_status\n            + len_pid\n            + len_created_at\n            + len_started_at\n            + len_exited_at\n            + len_stopped_at\n            + len_exit_code\n            + 9 * 2\n            + 11;\n        println!(\"{:-\u003clen_sum$}\", \"\", len_sum = len_sum);\n        println!(\n            \"| {: \u003clen_id$} | {: \u003clen_name$} | {: \u003clen_status$} | {: \u003clen_pid$} | {: \u003clen_created_at$} | {: \u003clen_started_at$} | {: \u003clen_exited_at$} | {: \u003clen_stopped_at$} | {: \u003clen_exit_code$} |\",\n            title_id, title_name, title_status, title_pid, title_created_at, title_started_at, title_exited_at, title_stopped_at, title_exit_code,\n            len_id = len_id, len_name = len_name, len_status = len_status + 1, len_pid = len_pid, len_created_at = len_created_at, len_started_at = len_started_at, len_exited_at = len_exited_at, len_stopped_at = len_stopped_at, len_exit_code = len_exit_code\n        );\n        let mut sum_running = 0;\n        let mut sum_stopped = 0;\n        let mut sum_waiting = 0;\n        let mut sum_added = 0;\n        let mut sum_interval = 0;\n        println!(\"{:-\u003clen_sum$}\", \"\", len_sum = len_sum);\n        for task in res {\n            let mut ling = \"·\".to_string();\n            if task.status == \"running\" {\n                ling = ling.green().to_string();\n                sum_running += 1;\n            } else if task.status == \"stopped\" {\n                ling = ling.red().to_string();\n                sum_stopped += 1;\n            } else if task.status == \"waiting\" {\n                ling = ling.blue().to_string();\n                sum_waiting += 1;\n            } else if task.status == \"added\" {\n                ling = ling.magenta().to_string();\n                sum_added += 1;\n            } else if task.status == \"interval\" {\n                ling = ling.cyan().to_string();\n                sum_interval += 1;\n            }\n            let created_at = if task.created_at \u003e 0 {\n                Local\n                    .timestamp_millis(task.created_at as i64)\n                    .format(\"%Y-%m-%d %H:%M:%S\")\n                    .to_string()\n            } else {\n                \"\".to_string()\n            };\n            let started_at = if task.started_at \u003e 0 {\n                Local\n                    .timestamp_millis(task.started_at as i64)\n                    .format(\"%Y-%m-%d %H:%M:%S\")\n                    .to_string()\n            } else {\n                \"\".to_string()\n            };\n            let exited_at = if task.exited_at \u003e 0 {\n                Local\n                    .timestamp_millis(task.exited_at as i64)\n                    .format(\"%Y-%m-%d %H:%M:%S\")\n                    .to_string()\n            } else {\n                \"\".to_string()\n            };\n            let stopped_at = if task.stopped_at \u003e 0 {\n                Local\n                    .timestamp_millis(task.stopped_at as i64)\n                    .format(\"%Y-%m-%d %H:%M:%S\")\n                    .to_string()\n            } else {\n                \"\".to_string()\n            };\n            let exit_code = if task.exit_code != 100 {\n                task.exit_code.to_string()\n            } else {\n                \"\".to_string()\n            };\n            println!(\n                \"| {: \u003clen_id$} | {: \u003clen_name$} | {}{: \u003clen_status$} | {: \u003clen_pid$} | {: \u003clen_created_at$} | {: \u003clen_started_at$} | {: \u003clen_exited_at$} | {: \u003clen_stopped_at$} | {: \u003clen_exit_code$} |\",\n                task.id, task.name, ling, task.status, task.pid, created_at, started_at, exited_at, stopped_at, exit_code,\n                len_id = len_id, len_name = len_name, len_status = len_status, len_pid = len_pid, len_created_at = len_created_at, len_started_at = len_started_at, len_exited_at = len_exited_at, len_stopped_at = len_stopped_at, len_exit_code = len_exit_code\n            );\n            println!(\"{:-\u003clen_sum$}\", \"\", len_sum = len_sum);\n        }\n        println!(\n            \"{} Total: {} running, {} stopped, {} added, {} waiting, {} interval\",\n            sum_all,\n            sum_running.to_string().green().to_string(),\n            sum_stopped.to_string().red().to_string(),\n            sum_added.to_string().magenta().to_string(),\n            sum_waiting.to_string().blue().to_string(),\n            sum_interval.to_string().cyan().to_string()\n        );\n    } else {\n        let len_sum = len_id\n            + len_name\n            + len_status\n            + len_pid\n            + len_started_at\n            + len_stopped_at\n            + len_exit_code\n            + 7 * 2\n            + 9;\n        println!(\"{:-\u003clen_sum$}\", \"\", len_sum = len_sum);\n        println!(\n            \"| {: \u003clen_id$} | {: \u003clen_name$} | {: \u003clen_status$} | {: \u003clen_pid$} | {: \u003clen_started_at$} | {: \u003clen_stopped_at$} | {: \u003clen_exit_code$} |\",\n            title_id, title_name, title_status, title_pid, title_started_at, title_stopped_at, title_exit_code,\n            len_id = len_id, len_name = len_name, len_status = len_status + 1, len_pid = len_pid, len_started_at = len_started_at, len_stopped_at = len_stopped_at, len_exit_code = len_exit_code\n        );\n        let mut sum_running = 0;\n        let mut sum_stopped = 0;\n        let mut sum_waiting = 0;\n        let mut sum_added = 0;\n        let mut sum_interval = 0;\n        println!(\"{:-\u003clen_sum$}\", \"\", len_sum = len_sum);\n        for task in res {\n            let mut ling = \"·\".to_string();\n            if task.status == \"running\" {\n                ling = ling.green().to_string();\n                sum_running += 1;\n            } else if task.status == \"stopped\" {\n                ling = ling.red().to_string();\n                sum_stopped += 1;\n            } else if task.status == \"waiting\" {\n                ling = ling.blue().to_string();\n                sum_waiting += 1;\n            } else if task.status == \"added\" {\n                ling = ling.magenta().to_string();\n                sum_added += 1;\n            } else if task.status == \"interval\" {\n                ling = ling.cyan().to_string();\n                sum_interval += 1;\n            }\n            let started_at = if task.started_at \u003e 0 {\n                Local\n                    .timestamp_millis(task.started_at as i64)\n                    .format(\"%Y-%m-%d %H:%M:%S\")\n                    .to_string()\n            } else {\n                \"\".to_string()\n            };\n            let stopped_at = if task.stopped_at \u003e 0 {\n                Local\n                    .timestamp_millis(task.stopped_at as i64)\n                    .format(\"%Y-%m-%d %H:%M:%S\")\n                    .to_string()\n            } else {\n                \"\".to_string()\n            };\n            let exit_code = if task.exit_code != 100 {\n                task.exit_code.to_string()\n            } else {\n                \"\".to_string()\n            };\n            println!(\n                \"| {: \u003clen_id$} | {: \u003clen_name$} | {}{: \u003clen_status$} | {: \u003clen_pid$} | {: \u003clen_started_at$} | {: \u003clen_stopped_at$} | {: \u003clen_exit_code$} |\",\n                task.id, task.name, ling, task.status, task.pid, started_at, stopped_at, exit_code,\n                len_id = len_id, len_name = len_name, len_status = len_status, len_pid = len_pid, len_started_at = len_started_at, len_stopped_at = len_stopped_at, len_exit_code = len_exit_code\n            );\n            println!(\"{:-\u003clen_sum$}\", \"\", len_sum = len_sum);\n        }\n        println!(\n            \"{} Total: {} running, {} stopped, {} added, {} waiting, {} interval\",\n            sum_all,\n            sum_running.to_string().green().to_string(),\n            sum_stopped.to_string().red().to_string(),\n            sum_added.to_string().magenta().to_string(),\n            sum_waiting.to_string().blue().to_string(),\n            sum_interval.to_string().cyan().to_string()\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","pause.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst PAUSE_HELP: \u0026str = r#\"Usage: watchmen pause [OPTION...] ...\n    -h, --help     display this help of 'pause' command\n\n    -i, --id       task id\n    -n, --name     task name\n    -p, --pid      task pid\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(PAUSE_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(PAUSE_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-p\" || args[0] == \"--pid\" {\n                    let pid = args[1].parse::\u003cu32\u003e();\n                    match pid {\n                        Ok(p) =\u003e {\n                            options.insert(\"pid\".to_string(), Opt::U32(p));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else if args[0] == \"-i\" || args[0] == \"--id\" {\n                    let id = args[1].parse::\u003cu128\u003e();\n                    match id {\n                        Ok(i) =\u003e {\n                            options.insert(\"id\".to_string(), Opt::U128(i));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n\n            let req = entity::Request {\n                name: \"pause\".to_string(),\n                command: entity::Command {\n                    name: \"pause\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","restart.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst RESTART_HELP: \u0026str = r#\"Usage: watchmen restart [OPTION...] ...\n    -h, --help      display this help of 'restart' command\n\n    -i, --id        task id\n    -n, --name      task name\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(RESTART_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(RESTART_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-i\" || args[0] == \"--id\" {\n                    let id = args[1].parse::\u003cu128\u003e();\n                    match id {\n                        Ok(i) =\u003e {\n                            options.insert(\"id\".to_string(), Opt::U128(i));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n\n            let req = entity::Request {\n                name: \"restart\".to_string(),\n                command: entity::Command {\n                    name: \"restart\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","resume.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst RESUME_HELP: \u0026str = r#\"Usage: watchmen resume [OPTION...] ...\n    -h, --help      display this help of 'resume' command\n\n    -i, --id        task id\n    -n, --name      task name\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(RESUME_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(RESUME_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-i\" || args[0] == \"--id\" {\n                    let id = args[1].parse::\u003cu128\u003e();\n                    match id {\n                        Ok(i) =\u003e {\n                            options.insert(\"id\".to_string(), Opt::U128(i));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n\n            let req = entity::Request {\n                name: \"resume\".to_string(),\n                command: entity::Command {\n                    name: \"resume\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","run.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst RUN_HELP: \u0026str = r#\"Usage: watchmen run [OPTION...] ...\n    -h, --help      display this help of 'run' command\n\n    -n, --name      task name\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(RUN_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(RUN_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-o\" || args[0] == \"--origin\" {\n                    let origin = args[1].parse::\u003cu128\u003e();\n                    match origin {\n                        Ok(o) =\u003e {\n                            options.insert(\"pid\".to_string(), Opt::U128(o));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else if args[0] == \"-i\" || args[0] == \"--interval\" {\n                    let interval = args[1].parse::\u003cu128\u003e();\n                    match interval {\n                        Ok(i) =\u003e {\n                            options.insert(\"interval\".to_string(), Opt::U128(i));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n            let req = entity::Request {\n                name: \"run\".to_string(),\n                command: entity::Command {\n                    name: \"run\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","start.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst START_HELP: \u0026str = r#\"Usage: watchmen start [OPTION...] ...\n    -h, --help      display this help of 'start' command\n\n    -i, --id        task id\n    -n, --name      task name\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(START_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(START_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-i\" || args[0] == \"--id\" {\n                    let id = args[1].parse::\u003cu128\u003e();\n                    match id {\n                        Ok(i) =\u003e {\n                            options.insert(\"id\".to_string(), Opt::U128(i));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n\n            let req = entity::Request {\n                name: \"start\".to_string(),\n                command: entity::Command {\n                    name: \"start\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","stop.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst STOP_HELP: \u0026str = r#\"Usage: watchmen stop [OPTION...] ...\n    -h, --help     display this help of 'start' command\n\n    -i, --id       task id\n    -n, --name     task name\n    -p, --pid      task pid\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(STOP_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(STOP_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-p\" || args[0] == \"--pid\" {\n                    let pid = args[1].parse::\u003cu32\u003e();\n                    match pid {\n                        Ok(p) =\u003e {\n                            options.insert(\"pid\".to_string(), Opt::U32(p));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else if args[0] == \"-i\" || args[0] == \"--id\" {\n                    let id = args[1].parse::\u003cu128\u003e();\n                    match id {\n                        Ok(i) =\u003e {\n                            options.insert(\"id\".to_string(), Opt::U128(i));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n\n            let req = entity::Request {\n                name: \"stop\".to_string(),\n                command: entity::Command {\n                    name: \"stop\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command.rs"],"content":"pub mod add;\npub mod exit;\npub mod list;\npub mod pause;\npub mod restart;\npub mod resume;\npub mod run;\npub mod start;\npub mod stop;\n\nuse std::fs::remove_file;\nuse std::io::Write;\nuse std::process::Stdio;\nuse std::{collections::HashMap, error::Error};\nuse tokio::process::Command;\n\nuse crate::{command, entity, socket};\n\nconst HELP: \u0026str = r#\"Usage: watchmen [OPTION|SUBCOMMAND] ...\n    -h, --help        display this help\n    -v, --version     display version\n    -i, --info        display information\n\n    -d, --daemon      startup watchmen daemon\n    -t, --terminated  terminated watchmen daemon\n\n    -gd, --guard-daemon         startup watchmen daemon\n    -gt, --guardt-terminated    terminated watchmen daemon\n\n    run\n        create a task and run it\n        run `watchmen run -h` for more information\n\n    add\n        create a task but not run it\n        run `watchmen add -h` for more information\n\n    drop | exit | rm\n        stop and drop a task\n        run `watchmen [this] -h` for more information\n\n    start\n        start a task if it is exists\n        run `watchmen start -h` for more information\n\n    restart\n        restart a task\n        run `watchmen restart -h` for more information\n\n    stop\n        stop a task\n        run `watchmen stop -h` for more information\n\n    pause\n        pause a scheduled task\n        run `watchmen stop -h` for more information\n\n    resume\n        resume a scheduled task\n        run `watchmen stop -h` for more information\n\n    list\n        list tasks\n        run `watchmen list -h` for more information\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\nconst INFO: \u0026str = r#\"watchmen 0.1.0\nHomepage: https://watchmen.ahriknow.com/\"\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\nconst VERSION: \u0026str = \"watchmen 0.1.0\";\n\npub async fn exec(\n    args: Vec\u003cString\u003e,\n    home_path: String,\n) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 2 {\n        return Ok(entity::Response::ok(HELP));\n    }\n    let response: entity::Response = match args[1].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response {\n            code: 10000,\n            msg: HELP.to_string(),\n            data: None,\n        },\n        \"-i\" | \"--info\" =\u003e entity::Response {\n            code: 10000,\n            msg: INFO.to_string(),\n            data: None,\n        },\n        \"-v\" | \"--version\" =\u003e entity::Response {\n            code: 10000,\n            msg: VERSION.to_string(),\n            data: None,\n        },\n        \"run\" =\u003e command::run::run(\u0026args[2..], home_path).await?,\n        \"add\" =\u003e command::add::run(\u0026args[2..], home_path).await?,\n        \"exit\" | \"rm\" | \"drop\" =\u003e command::exit::run(\u0026args[2..], home_path).await?,\n        \"start\" =\u003e command::start::run(\u0026args[2..], home_path).await?,\n        \"restart\" =\u003e command::restart::run(\u0026args[2..], home_path).await?,\n        \"stop\" =\u003e command::stop::run(\u0026args[2..], home_path).await?,\n        \"pause\" =\u003e command::pause::run(\u0026args[2..], home_path).await?,\n        \"resume\" =\u003e command::resume::run(\u0026args[2..], home_path).await?,\n        \"list\" =\u003e command::list::run(\u0026args[2..], home_path).await?,\n        \"-d\" | \"--daemon\" =\u003e start_daemon(\u0026args[2..], home_path).await?,\n        \"-t\" | \"--terminated\" =\u003e terminated_daemon(\u0026args[2..], home_path).await?,\n        \"-gd\" | \"--guard-daemon\" =\u003e start_guard_daemon(\u0026args[2..], home_path).await?,\n        \"-gt\" | \"--guardt-terminated\" =\u003e terminated_guard_daemon(\u0026args[2..], home_path).await?,\n        _ =\u003e {\n            let err: String = format!(\"watchmen: invalid command option '{}'\", args[1]);\n            entity::Response {\n                code: 40000,\n                msg: err,\n                data: None,\n            }\n        }\n    };\n\n    Ok(response)\n}\n\nasync fn start_daemon(\n    _args: \u0026[String],\n    home_path: String,\n) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let watchmen_path = std::path::Path::new(\u0026home_path);\n\n    let stdout_path = watchmen_path.join(\"stdout/\").clone();\n\n    let daemon_stdout = watchmen_path.join(\"daemon.log\").clone();\n    let file_result = std::fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(daemon_stdout.clone());\n    if file_result.is_err() {\n        let err: String = format!(\n            \"watchmen: cannot open stdout file '{}'\",\n            daemon_stdout.to_str().unwrap()\n        );\n        return Ok(entity::Response::err(err));\n    }\n    let stdout = Stdio::from(file_result.unwrap());\n\n    let sock_path = watchmen_path.join(\"watchmen.sock\");\n\n    let path = std::env::current_dir()?.join(\"daemon\");\n    // 子进程\n    let mut child = Command::new(path)\n        .arg(sock_path)\n        .arg(watchmen_path)\n        .arg(stdout_path)\n        .stdout(stdout)\n        .spawn()?;\n\n    let result = child.id();\n\n    match result {\n        Some(pid) =\u003e {\n            // 保存 pid\n            let path = std::path::Path::new(\u0026home_path);\n            let path = path.join(\"daemon.pid\");\n            // 创建文件\n            let mut file = std::fs::File::create(path.clone())?;\n            // 写入 pid\n            file.write_all(pid.to_string().as_bytes())?;\n\n            tokio::spawn(async move {\n                child.wait().await.unwrap();\n                remove_file(path).unwrap_or_default();\n            });\n            Ok(entity::Response::ok(format!(\"Start daemon pid: {}\", pid)))\n        }\n        None =\u003e Ok(entity::Response::err(\"watchmen: failed to start daemon\")),\n    }\n}\n\nextern \"C\" {\n    pub fn kill(pid: i32, sig: i32) -\u003e i32;\n}\n\nasync fn terminated_daemon(\n    args: \u0026[String],\n    home_path: String,\n) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let mut signal = 15;\n    if args.len() == 1 {\n        match args[0].as_str() {\n            \"-f\" | \"--force\" | \"-9\" =\u003e {\n                signal = 9;\n            }\n            _ =\u003e {\n                let err: String = format!(\"Invalid signal: '{}'\", args[0]);\n                return Err(err.into());\n            }\n        }\n    }\n\n    let daemon_pid_path = std::path::Path::new(\u0026home_path).join(\"daemon.pid\");\n    if !daemon_pid_path.exists() {\n        return Ok(entity::Response::err(format!(\n            \"Pid file not exists: {}\",\n            daemon_pid_path.display()\n        )));\n    }\n    let pid = std::fs::read_to_string(daemon_pid_path.clone())?;\n    let pid = pid.parse::\u003ci32\u003e()?;\n    let res = unsafe { kill(pid, signal) };\n    if res == 0 {\n        // 删除文件\n        remove_file(daemon_pid_path).unwrap_or_default();\n        return Ok(entity::Response::ok(format!(\n            \"Terminated daemon pid: {}\",\n            pid\n        )));\n    } else if res == -1 {\n        return Ok(entity::Response::err(format!(\n            \"Daemon process not exists: {}\",\n            pid\n        )));\n    } else {\n        return Ok(entity::Response::err(format!(\n            \"Terminated daemon error code: {}\",\n            res\n        )));\n    }\n}\n\nasync fn start_guard_daemon(\n    _args: \u0026[String],\n    home_path: String,\n) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let watchmen_path = std::path::Path::new(\u0026home_path);\n\n    let stdout_path = watchmen_path.join(\"stdout/\").clone();\n\n    let daemon_stdout = watchmen_path.join(\"guard.log\").clone();\n    let file_result = std::fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(daemon_stdout.clone());\n    if file_result.is_err() {\n        let err: String = format!(\n            \"watchmen: cannot open stdout file '{}'\",\n            daemon_stdout.to_str().unwrap()\n        );\n        return Ok(entity::Response::err(err));\n    }\n    let stdout = Stdio::from(file_result.unwrap());\n\n    let sock_path = watchmen_path.join(\"watchmen.sock\");\n\n    let path = std::env::current_dir()?.join(\"guard\");\n    // 子进程\n    let mut child = Command::new(path)\n        .arg(sock_path)\n        .arg(watchmen_path)\n        .arg(stdout_path)\n        .stdout(stdout)\n        .spawn()?;\n\n    let result = child.id();\n\n    match result {\n        Some(pid) =\u003e {\n            // 保存 pid\n            let path = std::path::Path::new(\u0026home_path);\n            let path = path.join(\"guard.pid\");\n            // 创建文件\n            let mut file = std::fs::File::create(path.clone())?;\n            // 写入 pid\n            file.write_all(pid.to_string().as_bytes())?;\n\n            tokio::spawn(async move {\n                child.wait().await.unwrap();\n                remove_file(path).unwrap_or_default();\n            });\n            Ok(entity::Response::ok(format!(\"Start guard pid: {}\", pid)))\n        }\n        None =\u003e Ok(entity::Response::err(\"watchmen: failed to start daemon\")),\n    }\n}\n\nasync fn terminated_guard_daemon(\n    _args: \u0026[String],\n    home_path: String,\n) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let options: HashMap\u003cstd::string::String, entity::Opt\u003e = HashMap::new();\n    let req = entity::Request {\n        name: \"terminated\".to_string(),\n        command: entity::Command {\n            name: \"terminated\".to_string(),\n            options: options,\n            args: vec![],\n        },\n    };\n    let res = socket::request(\u0026req, home_path.clone()).await?;\n    if res.code == 10 {\n        let path = std::path::Path::new(\u0026home_path).join(\"daemon.pid\");\n        remove_file(path).unwrap_or_default();\n    }\n    Ok(res)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","entity.rs"],"content":"use std::collections::HashMap;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Task {\n    pub id: u128,\n    pub name: String,\n    pub command: String,\n    pub args: Vec\u003cString\u003e,\n    pub status: String,\n    pub pid: u32,\n    pub created_at: u128,\n    pub started_at: u128,\n    pub exited_at: u128,\n    pub stopped_at: u128,\n    pub laststart_at: u128,\n    pub exit_code: u32,\n    pub interval: u128,\n    pub origin: u128,\n    pub timing: Vec\u003cu128\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub enum Opt {\n    U128(u128),\n    U128s(Vec\u003cu128\u003e),\n    U32(u32),\n    Str(String),\n    None,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Command {\n    pub name: String,\n    pub options: HashMap\u003cString, Opt\u003e,\n    pub args: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Request {\n    pub name: String,\n    pub command: Command,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub enum Data {\n    TaskList(Vec\u003cTask\u003e),\n    None,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Response {\n    pub code: u32,\n    pub msg: String,\n    pub data: Option\u003cData\u003e,\n}\n\nimpl Response {\n    pub fn new(code: u32, msg: String, data: Option\u003cData\u003e) -\u003e Self {\n        Self { code, msg, data }\n    }\n\n    pub fn ok\u003cT: ToString\u003e(msg: T) -\u003e Self {\n        Self {\n            code: 10000,\n            msg: msg.to_string(),\n            data: None,\n        }\n    }\n\n    pub fn data\u003cT: ToString\u003e(msg: T, data: Option\u003cData\u003e) -\u003e Self {\n        Self {\n            code: 10000,\n            msg: msg.to_string(),\n            data: data,\n        }\n    }\n\n    pub fn err\u003cT: ToString\u003e(msg: T) -\u003e Self {\n        Self {\n            code: 40000,\n            msg: msg.to_string(),\n            data: None,\n        }\n    }\n\n    pub fn f\u003cT: ToString\u003e(msg: T) -\u003e Self {\n        Self {\n            code: 40000,\n            msg: msg.to_string(),\n            data: None,\n        }\n    }\n}\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","ahri","watchmen","watchmen","src","lib.rs"],"content":"pub mod command;\npub mod entity;\npub mod socket;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","main.rs"],"content":"use clap::Parser;\nuse colored::Colorize;\nuse std::{env, error::Error, fs, process::exit};\n\nuse common::arg::TaskArgs;\nuse watchmen::command;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    let args = TaskArgs::parse();\n    if args.version {\n        println!(\n            \"{} {}\",\n            \"Watchmen rust\".green(),\n            env!(\"CARGO_PKG_VERSION\").green()\n        );\n        return Ok(());\n    }\n    println!(\"{:?}\", args);\n    return Ok(());\n    let watchmen_path = env::var(\"WATCHMEN_PATH\").unwrap_or_else(|_| \"/tmp/watchmen\".to_string());\n\n    let sock_path = std::path::Path::new(\u0026watchmen_path);\n\n    if !sock_path.exists() {\n        match fs::create_dir_all(sock_path) {\n            Ok(_) =\u003e {\n                println!(\"{} {}\", \"Created watchmen path: \".green(), watchmen_path);\n            }\n            Err(err) =\u003e {\n                eprintln!(\"{} {}\", \"Error creating watchmen path: \".red(), err);\n                exit(1);\n            }\n        }\n    }\n\n    let stdout_path = sock_path.join(\"stdout/\").clone();\n    if !stdout_path.exists() {\n        match fs::create_dir(stdout_path.clone()) {\n            Ok(_) =\u003e {\n                println!(\n                    \"{} {}\",\n                    \"Created stdout path: \".green(),\n                    stdout_path.display()\n                );\n            }\n            Err(err) =\u003e {\n                eprintln!(\"{} {}\", \"Error creating stdout path: \".red(), err);\n                exit(1);\n            }\n        }\n    }\n\n    // 命令行参数 / command line arguments\n    let args: Vec\u003cString\u003e = std::env::args().collect();\n    // 执行命令 / execute command\n    let response = command::exec(args, watchmen_path).await;\n    match response {\n        Ok(res) =\u003e {\n            let code;\n            if res.code == 10 {\n                println!(\"{}\", res.msg.green());\n                code = 0;\n            } else if res.code \u003e= 50000 {\n                println!(\"{}\", res.msg.blue());\n                code = 1;\n            } else if res.code \u003e= 40000 {\n                println!(\"{}\", res.msg.red());\n                code = 1;\n            } else if res.code \u003e= 20000 {\n                println!(\"{}\", res.msg.yellow());\n                code = 1;\n            } else if res.code \u003e= 10000 {\n                println!(\"{}\", res.msg.green());\n                code = 0;\n            } else {\n                println!(\"{}\", res.msg);\n                code = 1;\n            }\n            exit(code);\n        }\n        Err(err) =\u003e {\n            eprintln!(\"{}\", err);\n            exit(1);\n        }\n    }\n}\n\n#[cfg(test)]\npub mod tests {\n\n    #[test]\n    fn test_clap() {\n        unsafe {\n            let lib = libloading::Library::new(\"/tmp/watchmen/plugins/libplugin.so\").unwrap();\n            let func: libloading::Symbol\u003cunsafe extern \"C\" fn(t: i32) -\u003e bool\u003e =\n                lib.get(b\"func_plugin\").unwrap();\n            println!(\"PLUGIN: {:?}\", func(1));\n        }\n        assert_eq!(1, 1);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","socket.rs"],"content":"use std::{error::Error, path::Path};\nuse tokio::{\n    io::{AsyncReadExt, AsyncWriteExt},\n    net::UnixStream,\n};\n\nuse crate::entity;\n\npub async fn request(request: \u0026entity::Request, home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    // 判断文件夹是否存在\n    let path = Path::new(\u0026home_path);\n\n    let socket_path: \u0026Path = \u0026path.join(\"watchmen.sock\");\n    if !socket_path.exists() {\n        return Err(\"Daemon is not running\".into());\n    }\n    let mut stream = UnixStream::connect(socket_path).await?;\n    // Send request\n    let buf = serde_json::to_vec(request)?;\n    stream.write_all(\u0026buf).await?;\n    // 接收数据\n    let mut buf: [u8; 1024] = [0; 1024];\n    let n = stream.read(\u0026mut buf).await?;\n    let res: entity::Response = serde_json::from_slice(\u0026buf[..n])?;\n    Ok(res)\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","ahri","watchmen","common","src","arg.rs"],"content":"use clap::{Args, Parser, Subcommand};\n\n#[derive(Debug, Parser, PartialEq)]\n#[command(author, about)]\npub struct TaskArgs {\n    /// Config file path.\n    /// Default: $HOME/.watchmen/config.toml\n    #[arg(short, long)]\n    pub config: Option\u003cString\u003e,\n\n    /// Print version\n    #[arg(short, long)]\n    pub version: bool,\n\n    /// SubCommands\n    #[command(subcommand)]\n    pub commands: Option\u003cCommands\u003e,\n}\n\n#[derive(Debug, Subcommand, PartialEq)]\npub enum Commands {\n    /// Add and run a task\n    Run(RunArgs),\n}\n\n#[derive(Args, Debug, PartialEq)]\npub struct RunArgs {\n    /// Task config directory\n    #[arg(short = 'l', long)]\n    pub all: Option\u003cString\u003e,\n\n    /// Task config file\n    #[arg(short = 'f', long)]\n    pub config: Option\u003cString\u003e,\n\n    /// Task name (unique)\n    #[arg(short, long)]\n    pub name: String,\n\n    /// Task command\n    #[arg(short, long)]\n    pub command: String,\n\n    /// Task arguments\n    #[arg(short, long)]\n    pub args: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Task working directory\n    #[arg(short = 'd', long)]\n    pub dir: Option\u003cString\u003e,\n\n    /// Task environment variables\n    #[arg(short = 'e', long)]\n    pub env: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Task standard input\n    #[arg(short = 'i', long)]\n    pub stdin: Option\u003cString\u003e,\n\n    /// Task standard output\n    #[arg(short = 'o', long)]\n    pub stdout: Option\u003cString\u003e,\n\n    /// Task standard error\n    #[arg(short = 'r', long)]\n    pub stderr: Option\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","common","src","lib.rs"],"content":"pub mod arg;\npub mod task;\npub mod trait_arg;\npub mod trait_task;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","common","src","task.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::{\n    collections::HashMap,\n    time::{SystemTime, UNIX_EPOCH},\n};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct ScheduledTask {\n    pub year: Option\u003cu64\u003e,\n    pub month: Option\u003cu64\u003e,\n    pub day: Option\u003cu64\u003e,\n    pub hour: Option\u003cu64\u003e,\n    pub minute: Option\u003cu64\u003e,\n    pub second: Option\u003cu64\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct AsyncTask {\n    pub started_at: u64,\n    pub stopped_at: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct PeriodicTask {\n    pub started_after: u64,\n    pub interval: u64,\n    pub last_run: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub enum TaskType {\n    Scheduled(ScheduledTask),\n    Async(AsyncTask),\n    Periodic(PeriodicTask),\n    None,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Task {\n    /// Task id (unique)\n    pub id: i64,\n\n    /// Task name (unique)\n    pub name: String,\n\n    /// Task command\n    pub command: String,\n\n    /// Task arguments\n    pub args: Vec\u003cString\u003e,\n\n    /// Task working directory\n    pub dir: String,\n\n    /// Task environment variables\n    pub env: HashMap\u003cString, String\u003e,\n\n    pub stdin: Option\u003cString\u003e,\n    pub stdout: Option\u003cString\u003e,\n    pub stderr: Option\u003cString\u003e,\n\n    pub created_at: u64,\n    pub task_type: TaskType,\n}\n\nimpl Default for Task {\n    fn default() -\u003e Self {\n        let now = SystemTime::now();\n        let timestamp = now\n            .duration_since(UNIX_EPOCH)\n            .expect(\"Failed to get timestamp\")\n            .as_secs();\n        Task {\n            id: 0,\n            name: \"\".to_string(),\n            command: \"\".to_string(),\n            args: vec![],\n            dir: \"\".to_string(),\n            env: HashMap::new(),\n            stdin: None,\n            stdout: None,\n            stderr: None,\n            created_at: timestamp,\n            task_type: TaskType::None,\n        }\n    }\n}\n\nunsafe impl Send for Task {}\nunsafe impl Sync for Task {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","common","src","trait_arg.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","common","src","trait_task.rs"],"content":"use std::error::Error;\n\nuse configparser::ini::Ini;\n\nuse crate::task::{AsyncTask, PeriodicTask, ScheduledTask, Task, TaskType};\n\nimpl Task {\n    pub fn from_ini(args: Ini, section: \u0026str) -\u003e Result\u003cTask, Box\u003cdyn Error\u003e\u003e {\n        let mut task = Task::default();\n        task.id = args.getint(section, \"id\")?.unwrap();\n        task.name = args.get(section, \"name\").unwrap();\n        task.command = args.get(section, \"command\").unwrap();\n        task.args = args\n            .get(section, \"args\")\n            .unwrap_or(\"\".to_string())\n            .split(\" \")\n            .map(|s| s.to_string())\n            .collect();\n        task.dir = args\n            .get(section, \"dir\")\n            .unwrap_or(std::env::current_dir()?.to_str().unwrap().to_string());\n        for env in args\n            .get(section, \"env\")\n            .unwrap_or(\"\".to_string())\n            .split(\" \")\n        {\n            let kv: Vec\u003c\u0026str\u003e = env.split(\"=\").collect();\n            if kv.len() == 2 {\n                task.env.insert(kv[0].to_string(), kv[1].to_string());\n            }\n        }\n        task.stdin = args.get(section, \"stdin\");\n        task.stdout = args.get(section, \"stdout\");\n        task.stderr = args.get(section, \"stderr\");\n\n        let task_type = args.get(section, \"task_type\").unwrap_or(\"none\".to_string());\n\n        let tt = match task_type.as_str() {\n            \"scheduled\" =\u003e {\n                let mut tt = ScheduledTask {\n                    year: None,\n                    month: None,\n                    day: None,\n                    hour: None,\n                    minute: None,\n                    second: None,\n                };\n                if let Some(year) = args.getint(section, \"year\")? {\n                    if year \u003c 1970 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid year: {}\", year),\n                        )));\n                    }\n                    tt.year = Some(year as u64);\n                }\n                if let Some(month) = args.getint(section, \"month\")? {\n                    if month \u003c 1 || month \u003e 12 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid month: {}\", month),\n                        )));\n                    }\n                    tt.month = Some(month as u64);\n                }\n                if let Some(day) = args.getint(section, \"day\")? {\n                    if day \u003c 1 || day \u003e 31 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid day: {}\", day),\n                        )));\n                    }\n                    tt.day = Some(day as u64);\n                }\n                if let Some(hour) = args.getint(section, \"hour\")? {\n                    if hour \u003c 0 || hour \u003e 23 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid hour: {}\", hour),\n                        )));\n                    }\n                    tt.hour = Some(hour as u64);\n                }\n                if let Some(minute) = args.getint(section, \"minute\")? {\n                    if minute \u003c 0 || minute \u003e 59 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid minute: {}\", minute),\n                        )));\n                    }\n                    tt.minute = Some(minute as u64);\n                }\n                if let Some(second) = args.getint(section, \"second\")? {\n                    if second \u003c 0 || second \u003e 59 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid second: {}\", second),\n                        )));\n                    }\n                    tt.second = Some(second as u64);\n                }\n                TaskType::Scheduled(tt)\n            }\n            \"async\" =\u003e TaskType::Async(AsyncTask {\n                started_at: 0,\n                stopped_at: 0,\n            }),\n            \"periodic\" =\u003e {\n                let mut tt = PeriodicTask {\n                    started_after: 0,\n                    interval: 60,\n                    last_run: 0,\n                };\n                if let Some(started_after) = args.getint(section, \"started_after\")? {\n                    if started_after \u003c 0 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid started_after: {}\", started_after),\n                        )));\n                    }\n                    tt.started_after = started_after as u64;\n                }\n                if let Some(interval) = args.getint(section, \"interval\")? {\n                    if interval \u003c= 0 {\n                        return Err(Box::new(std::io::Error::new(\n                            std::io::ErrorKind::Other,\n                            format!(\"Invalid interval: {}\", interval),\n                        )));\n                    }\n                    tt.interval = interval as u64;\n                }\n                TaskType::Periodic(tt)\n            }\n            _ =\u003e {\n                return Err(Box::new(std::io::Error::new(\n                    std::io::ErrorKind::Other,\n                    format!(\"Invalid task_type: {}\", task_type),\n                )));\n            }\n        };\n        task.task_type = tt;\n\n        Ok(task)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","common","tests","arg_test.rs"],"content":"#[cfg(test)]\nmod tests {\n    use clap::Parser;\n    use common::arg::{Commands, RunArgs, TaskArgs};\n\n    #[test]\n    fn test_arg() {\n        let args = TaskArgs::parse_from([\"--\", \"-v\"]);\n        assert!(args.version);\n\n        let args = TaskArgs::parse_from([\"--\", \"run\", \"-n\", \"test\", \"-c\", \"rustc\"]);\n        let cmd = Commands::Run(RunArgs {\n            all: None,\n            config: None,\n            name: \"test\".to_string(),\n            command: \"rustc\".to_string(),\n            args: None,\n            dir: None,\n            env: None,\n            stdin: None,\n            stdout: None,\n            stderr: None,\n        });\n        assert_eq!(args.commands, Some(cmd));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","common","tests","task_from_ini_test.rs"],"content":"#[cfg(test)]\nmod tests {\n    use std::collections::HashMap;\n\n    use common::task::{AsyncTask, PeriodicTask, ScheduledTask, Task, TaskType};\n    use configparser::ini::Ini;\n\n    #[test]\n    fn test_task_from_ini_0() {\n        let mut ini = Ini::new();\n        let config_path = std::env::current_dir().unwrap().join(\"tests/ini/task.ini\");\n        ini.load(\u0026config_path).unwrap();\n\n        let mut sections_reality = ini.sections();\n        assert_eq!(sections_reality.len(), 3);\n\n        let mut sections_expect = vec![\n            \"test_section_name1\",\n            \"test_section_name2\",\n            \"test_section_name3\",\n        ];\n        assert_eq!(sections_reality.sort(), sections_expect.sort());\n\n        let mut task = Task::from_ini(ini.clone(), \"test_section_name1\").unwrap();\n        let mut env = HashMap::new();\n        env.insert(\"key1\".to_string(), \"value1\".to_string());\n        env.insert(\"key2\".to_string(), \"value2\".to_string());\n        task.created_at = 0;\n        assert_eq!(\n            task,\n            Task {\n                id: 1,\n                name: \"test_name1\".to_string(),\n                command: \"test_command\".to_string(),\n                args: vec![\"arg1\".to_string(), \"arg2\".to_string()],\n                dir: \"/home/user\".to_string(),\n                env,\n                stdin: Some(\"test_stdin\".to_string()),\n                stdout: Some(\"test_stdout\".to_string()),\n                stderr: Some(\"test_stderr\".to_string()),\n                created_at: 0,\n                task_type: TaskType::Scheduled(ScheduledTask {\n                    year: Some(2000),\n                    month: Some(1),\n                    day: Some(1),\n                    hour: Some(1),\n                    minute: Some(1),\n                    second: Some(1),\n                })\n            }\n        );\n\n        let mut task = Task::from_ini(ini.clone(), \"test_section_name2\").unwrap();\n        let mut env = HashMap::new();\n        env.insert(\"key1\".to_string(), \"value1\".to_string());\n        env.insert(\"key2\".to_string(), \"value2\".to_string());\n        task.created_at = 0;\n        assert_eq!(\n            task,\n            Task {\n                id: 2,\n                name: \"test_name2\".to_string(),\n                command: \"test_command\".to_string(),\n                args: vec![\"arg1\".to_string(), \"arg2\".to_string()],\n                dir: \"/home/user\".to_string(),\n                env,\n                stdin: None,\n                stdout: None,\n                stderr: None,\n                created_at: 0,\n                task_type: TaskType::Async(AsyncTask {\n                    started_at: 0,\n                    stopped_at: 0,\n                })\n            }\n        );\n\n        let mut task = Task::from_ini(ini.clone(), \"test_section_name3\").unwrap();\n        let mut env = HashMap::new();\n        env.insert(\"key1\".to_string(), \"value1\".to_string());\n        env.insert(\"key2\".to_string(), \"value2\".to_string());\n        task.created_at = 0;\n        assert_eq!(\n            task,\n            Task {\n                id: 3,\n                name: \"test_name3\".to_string(),\n                command: \"test_command\".to_string(),\n                args: vec![\"arg1\".to_string(), \"arg2\".to_string()],\n                dir: \"/home/user\".to_string(),\n                env,\n                stdin: None,\n                stdout: None,\n                stderr: None,\n                created_at: 0,\n                task_type: TaskType::Periodic(PeriodicTask {\n                    started_after: 10000,\n                    interval: 600,\n                    last_run: 0,\n                })\n            }\n        );\n    }\n\n    #[test]\n    fn test_task_from_ini_1() {\n        let mut ini = Ini::new();\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_year_1969.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid year: 1969\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_month_13.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid month: 13\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_day_32.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid day: 32\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_hour_24.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid hour: 24\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_minute_60.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid minute: 60\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_second_60.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid second: 60\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_task_type_none.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid task_type: xxx\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_started_after.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid started_after: -1\");\n\n        let config_path = std::env::current_dir()\n            .unwrap()\n            .join(\"tests/ini/error_interval.ini\");\n        ini.load(\u0026config_path).unwrap();\n        let task = Task::from_ini(ini.clone(), \"test_section_name\");\n        let err_msg = task.unwrap_err().to_string();\n        assert_eq!(err_msg, \"Invalid interval: 0\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","add.rs"],"content":"use std::error::Error;\n\nuse crate::entity::{self, Task};\nuse crate::global::{add_task, check_exists};\n\nasync fn register(task: Task) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    add_task(task).await?;\n    Ok(())\n}\n\npub async fn add_a_task(task: Task) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let args_cmdline: Vec\u003cString\u003e = std::env::args().collect();\n    if args_cmdline.len() \u003c 3 {\n        return Ok(entity::Response {\n            code: 50000,\n            msg: \"Miss stdout path\".to_string(),\n            data: None,\n        });\n    }\n\n    let exists = check_exists(task.name.clone()).await?;\n    if exists {\n        return Ok(entity::Response {\n            code: 40000,\n            msg: \"Task already exists\".to_string(),\n            data: None,\n        });\n    }\n\n    let t = task.clone();\n    register(t).await?;\n\n    return Ok(entity::Response {\n        code: 10000,\n        msg: \"Task added successfully\".to_string(),\n        data: None,\n    });\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","exit.rs"],"content":"use std::error::Error;\n\nuse crate::{\n    entity,\n    global::{get_task_by_id, get_task_by_name, get_task_by_pid, remove_task_by_name},\n};\n\nextern \"C\" {\n    pub fn kill(pid: i32, sig: i32) -\u003e i32;\n}\n\npub async fn exit_task(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let task;\n    if command.options.contains_key(\"id\") {\n        let id = command.options.get(\"id\").unwrap();\n        if let entity::Opt::U128(ref i) = id {\n            task = get_task_by_id(*i).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'id' must be a usize\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"name\") {\n        let name = command.options.get(\"name\").unwrap();\n        if let entity::Opt::Str(ref s) = name {\n            task = get_task_by_name(s.clone()).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'name' must be a string\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"pid\") {\n        let name = command.options.get(\"pid\").unwrap();\n        if let entity::Opt::U32(ref s) = name {\n            task = get_task_by_pid(*s).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'pid' must be a number\".to_string(),\n                data: None,\n            });\n        }\n    } else {\n        if command.args.len() == 0 {\n            return Ok(entity::Response {\n                code: 40000,\n                msg: \"Arg 'name' or 'pid' is required\".to_string(),\n                data: None,\n            });\n        } else {\n            task = get_task_by_name(command.args[0].clone()).await?;\n        }\n    }\n\n    let pid = task.pid;\n    if task.status == \"running\" {\n        let res = unsafe { kill(pid as i32, 15) };\n        if res == 0 {\n            remove_task_by_name(task.name).await?;\n            let res = entity::Response {\n                code: 10000,\n                msg: format!(\"{} success\", command.name),\n                data: None,\n            };\n            return Ok(res);\n        }\n        let res = entity::Response {\n            code: 40000,\n            msg: \"failed\".to_string(),\n            data: None,\n        };\n        return Ok(res);\n    } else {\n        remove_task_by_name(task.name).await?;\n        let res = entity::Response {\n            code: 10000,\n            msg: format!(\"{} success\", command.name),\n            data: None,\n        };\n        return Ok(res);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","list.rs"],"content":"use std::error::Error;\n\nuse crate::{\n    entity::{self, Task},\n    global::get_all_tasks,\n};\n\npub async fn list_tasks(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let mut task_list: Vec\u003cTask\u003e = Vec::new();\n    let tasks = get_all_tasks().await?;\n\n    for task in tasks.iter() {\n        let mut flag = true;\n        for (key, value) in command.options.iter() {\n            if key == \"name\" {\n                match value {\n                    entity::Opt::Str(ref s) =\u003e {\n                        if !task.name.contains(s) {\n                            flag = false;\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n            if key == \"status\" {\n                match value {\n                    entity::Opt::Str(ref s) =\u003e {\n                        if !task.status.contains(s) {\n                            flag = false;\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n            if key == \"pid\" {\n                match value {\n                    entity::Opt::U32(ref s) =\u003e {\n                        if task.pid != *s {\n                            flag = false;\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n        }\n        if flag {\n            task_list.push(task.clone());\n        }\n    }\n\n    let res = entity::Response {\n        code: 10000,\n        msg: format!(\"{} success\", command.name),\n        data: Some(entity::Data::TaskList(task_list)),\n    };\n    Ok(res)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","pause.rs"],"content":"use std::error::Error;\n\nuse crate::{\n    entity,\n    global::{get_task_by_id, get_task_by_name, get_task_by_pid, update_status_by_name},\n};\n\npub async fn pause_task(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let task;\n    if command.options.contains_key(\"id\") {\n        let id = command.options.get(\"id\").unwrap();\n        if let entity::Opt::U128(ref i) = id {\n            task = get_task_by_id(*i).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'id' must be a usize\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"name\") {\n        let name = command.options.get(\"name\").unwrap();\n        if let entity::Opt::Str(ref s) = name {\n            task = get_task_by_name(s.clone()).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'name' must be a string\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"pid\") {\n        let name = command.options.get(\"pid\").unwrap();\n        if let entity::Opt::U32(ref s) = name {\n            task = get_task_by_pid(*s).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'pid' must be a number\".to_string(),\n                data: None,\n            });\n        }\n    } else {\n        if command.args.len() == 0 {\n            return Ok(entity::Response {\n                code: 40000,\n                msg: \"Arg 'name' or 'pid' is required\".to_string(),\n                data: None,\n            });\n        } else {\n            task = get_task_by_name(command.args[0].clone()).await?;\n        }\n    }\n\n    if task.status != \"interval\" {\n        return Ok(entity::Response {\n            code: 40000,\n            msg: \"Task is not interval\".to_string(),\n            data: None,\n        });\n    }\n\n    update_status_by_name(task.name, \"paused\".to_string()).await?;\n\n    let res = entity::Response {\n        code: 10000,\n        msg: format!(\"{} success\", command.name),\n        data: None,\n    };\n    return Ok(res);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","restart.rs"],"content":"use std::error::Error;\n\nuse crate::entity;\n\nuse super::start;\nuse super::stop;\n\npub async fn restart_task(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let res1 = stop::stop_task(command.clone()).await?;\n    if res1.code == 10000 {\n        let res2 = start::start_task(command).await?;\n        if res2.code == 10000 {\n            return Ok(entity::Response {\n                code: 10000,\n                msg: \"restart success\".to_string(),\n                data: None,\n            });\n        } else {\n            return Ok(res2);\n        }\n    } else {\n        return Ok(res1);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","resume.rs"],"content":"use std::error::Error;\n\nuse crate::entity;\nuse crate::global::{get_task_by_id, get_task_by_name, update_status_by_name};\n\npub async fn resume_task(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let task;\n    if command.options.contains_key(\"id\") {\n        let id = command.options.get(\"id\").unwrap();\n        if let entity::Opt::U128(ref i) = id {\n            task = get_task_by_id(*i).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'id' must be a usize\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"name\") {\n        let name = command.options.get(\"name\").unwrap();\n        if let entity::Opt::Str(ref s) = name {\n            task = get_task_by_name(s.clone()).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'name' must be a string\".to_string(),\n                data: None,\n            });\n        }\n    } else {\n        if command.args.len() == 0 {\n            return Ok(entity::Response {\n                code: 40000,\n                msg: \"Arg 'name' is required\".to_string(),\n                data: None,\n            });\n        } else {\n            task = get_task_by_name(command.args[0].clone()).await?;\n        }\n    }\n\n    if task.status != \"paused\" \u0026\u0026 task.status != \"waiting\" {\n        return Ok(entity::Response {\n            code: 40000,\n            msg: format!(\"Task with '{}' could not be resumed\", task.status),\n            data: None,\n        });\n    }\n\n    update_status_by_name(task.name, \"interval\".to_string()).await?;\n\n    let res = entity::Response {\n        code: 10000,\n        msg: format!(\"{} success\", command.name),\n        data: None,\n    };\n    return Ok(res);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","run.rs"],"content":"use chrono::prelude::{DateTime, Local};\nuse std::{env, error::Error, path::Path, process::Stdio};\nuse tokio::process::{Child, Command};\n\nuse crate::entity::{self, Task};\nuse crate::global::{\n    add_task, check_exists, update_exit_code_by_name, update_pid_by_name, update_started_at_by_id,\n    update_status_by_name,\n};\n\nasync fn register(task: Task) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    add_task(task).await?;\n    Ok(())\n}\n\nasync fn update_pid(name: String, pid: u32) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    update_pid_by_name(name, pid).await?;\n    Ok(())\n}\n\nasync fn update_status(name: String, status: String) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    update_status_by_name(name, status).await?;\n    Ok(())\n}\n\npub async fn run_task(task: Task) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let args_cmdline: Vec\u003cString\u003e = std::env::args().collect();\n    if args_cmdline.len() \u003c 3 {\n        return Ok(entity::Response {\n            code: 50000,\n            msg: \"Miss stdout path\".to_string(),\n            data: None,\n        });\n    }\n\n    let exists = check_exists(task.name.clone()).await?;\n    if exists {\n        return Ok(entity::Response {\n            code: 40000,\n            msg: \"Task already exists\".to_string(),\n            data: None,\n        });\n    }\n\n    let t = task.clone();\n    register(t).await?;\n\n    // 声明指向文件的 stdout\n    let path = Path::new(\u0026args_cmdline[3]);\n    let path = path.join(format!(\"{}.log\", task.name));\n\n    // 创建或追加文件\n    let file = std::fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(path)?;\n\n    let stdout = Stdio::from(file);\n\n    let time: DateTime\u003cLocal\u003e = Local::now();\n    let now = time.timestamp_millis() as u128;\n\n    crate::info!(\"TASK\\tRUN\\t{:?}\", task);\n\n    // 获取环境变量 PATH\n    let env_path = env::var(\"PATH\")?;\n    let mut child: Child = Command::new(\u0026task.command)\n        .args(\u0026task.args)\n        .env(\"PATH\", env_path)\n        .stdin(Stdio::null())\n        .stdout(stdout)\n        .stderr(Stdio::null())\n        .spawn()?;\n\n    let result = child.id();\n\n    let code = match result {\n        Some(pid) =\u003e {\n            // 更改 task pid\n            update_pid(task.name.clone(), pid).await.unwrap();\n            // 更改 task status\n            update_status(task.name.clone(), \"running\".to_string())\n                .await\n                .unwrap();\n            update_started_at_by_id(task.id, now).await.unwrap();\n            // 异步等待子进程结束并更改 task status\n            tokio::spawn(async move {\n                let s = child.wait().await.unwrap();\n                let exit_code = s.code().unwrap_or(-1);\n                crate::info!(\"TASK\\tSTOP\\t{}\\t{:?}\", exit_code, task);\n                update_status(task.name.clone(), \"stopped\".to_string())\n                    .await\n                    .unwrap();\n                update_pid(task.name.clone(), 0).await.unwrap();\n                if let Some(code) = s.code() {\n                    update_exit_code_by_name(task.name.clone(), code as u32)\n                        .await\n                        .unwrap();\n                }\n            });\n            10000\n        }\n        None =\u003e 40000,\n    };\n    if code \u003e 0 {\n        return Ok(entity::Response {\n            code: 10000,\n            msg: \"run success\".to_string(),\n            data: None,\n        });\n    } else {\n        return Ok(entity::Response {\n            code: 40000,\n            msg: \"run failed\".to_string(),\n            data: None,\n        });\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","start.rs"],"content":"use chrono::prelude::{DateTime, Local};\nuse std::{env, error::Error, path::Path, process::Stdio};\nuse tokio::process::{Child, Command};\n\nuse crate::entity;\nuse crate::global::{\n    get_task_by_id, get_task_by_name, update_exit_code_by_name, update_pid_by_name,\n    update_started_at_by_id, update_status_by_name,\n};\n\nasync fn update_pid(name: String, pid: u32) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    update_pid_by_name(name, pid).await?;\n    Ok(())\n}\n\nasync fn update_status(name: String, status: String) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    update_status_by_name(name, status).await?;\n    Ok(())\n}\n\npub async fn start_task_by_task(task: entity::Task) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let args_cmdline: Vec\u003cString\u003e = std::env::args().collect();\n    if args_cmdline.len() \u003c 3 {\n        return Ok(entity::Response {\n            code: 50000,\n            msg: \"Miss stdout path\".to_string(),\n            data: None,\n        });\n    }\n\n    // 声明指向文件的 stdout\n    let path = Path::new(\u0026args_cmdline[3]);\n    let path = path.join(format!(\"{}.log\", task.name));\n\n    // 创建或追加文件\n    let file = std::fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(path)?;\n    let stdout = Stdio::from(file);\n\n    // 获取环境变量 PATH\n    let env_path = env::var(\"PATH\")?;\n    let mut child: Child = Command::new(\u0026task.command)\n        .args(\u0026task.args)\n        .env(\"PATH\", env_path)\n        .stdin(Stdio::null())\n        .stdout(stdout)\n        .stderr(Stdio::null())\n        .spawn()?;\n\n    let result = child.id();\n\n    match result {\n        Some(pid) =\u003e {\n            // 更改 task pid\n            update_pid(task.name.clone(), pid).await?;\n            // 更改 task status\n            update_status(task.name.clone(), \"running\".to_string()).await?;\n            // 异步等待子进程结束并更改 task status\n            tokio::spawn(async move {\n                let s = child.wait().await.unwrap();\n                update_status(task.name.clone(), \"stopped\".to_string())\n                    .await\n                    .unwrap();\n                update_pid(task.name.clone(), 0).await.unwrap();\n                if let Some(code) = s.code() {\n                    update_exit_code_by_name(task.name.clone(), code as u32)\n                        .await\n                        .unwrap();\n                }\n            });\n            Ok(entity::Response {\n                code: 10000,\n                msg: \"start success\".to_string(),\n                data: None,\n            })\n        }\n        None =\u003e Ok(entity::Response {\n            code: 40000,\n            msg: \"start failed\".to_string(),\n            data: None,\n        }),\n    }\n}\n\npub async fn start_task(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let task;\n    if command.options.contains_key(\"id\") {\n        let id = command.options.get(\"id\").unwrap();\n        if let entity::Opt::U128(ref i) = id {\n            task = get_task_by_id(*i).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'id' must be a usize\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"name\") {\n        let name = command.options.get(\"name\").unwrap();\n        if let entity::Opt::Str(ref s) = name {\n            task = get_task_by_name(s.clone()).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'name' must be a string\".to_string(),\n                data: None,\n            });\n        }\n    } else {\n        if command.args.len() == 0 {\n            return Ok(entity::Response {\n                code: 40000,\n                msg: \"Arg 'name' is required\".to_string(),\n                data: None,\n            });\n        } else {\n            task = get_task_by_name(command.args[0].clone()).await?;\n        }\n    }\n\n    if task.status != \"stopped\" \u0026\u0026 task.status != \"added\" {\n        return Ok(entity::Response {\n            code: 40000,\n            msg: format!(\"Task with '{}' could not be started\", task.status),\n            data: None,\n        });\n    }\n\n    let args_cmdline: Vec\u003cString\u003e = std::env::args().collect();\n    if args_cmdline.len() \u003c 3 {\n        return Ok(entity::Response {\n            code: 50000,\n            msg: \"Miss stdout path\".to_string(),\n            data: None,\n        });\n    }\n\n    // 声明指向文件的 stdout\n    let path = Path::new(\u0026args_cmdline[3]);\n    let path = path.join(format!(\"{}.log\", task.name));\n\n    // 创建或追加文件\n    let file = std::fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(path)?;\n    let stdout = Stdio::from(file);\n\n    let time: DateTime\u003cLocal\u003e = Local::now();\n    let now = time.timestamp_millis() as u128;\n\n    crate::info!(\"TASK\\tSTART\\t{:?}\", task);\n\n    // 获取环境变量 PATH\n    let env_path = env::var(\"PATH\")?;\n    let mut child: Child = Command::new(\u0026task.command)\n        .args(\u0026task.args)\n        .env(\"PATH\", env_path)\n        .stdin(Stdio::null())\n        .stdout(stdout)\n        .stderr(Stdio::null())\n        .spawn()?;\n\n    let result = child.id();\n\n    match result {\n        Some(pid) =\u003e {\n            // 更改 task pid\n            update_pid(task.name.clone(), pid).await.unwrap();\n            // 更改 task status\n            update_status(task.name.clone(), \"running\".to_string())\n                .await\n                .unwrap();\n            update_started_at_by_id(task.id, now).await.unwrap();\n            // 异步等待子进程结束并更改 task status\n            tokio::spawn(async move {\n                let s = child.wait().await.unwrap();\n                let exit_code = s.code().unwrap_or(-1);\n                crate::info!(\"TASK\\tSTOP\\t{}\\t{:?}\", exit_code, task);\n                update_status(task.name.clone(), \"stopped\".to_string())\n                    .await\n                    .unwrap();\n                update_pid(task.name.clone(), 0).await.unwrap();\n                if let Some(code) = s.code() {\n                    update_exit_code_by_name(task.name.clone(), code as u32)\n                        .await\n                        .unwrap();\n                }\n            });\n            Ok(entity::Response {\n                code: 10000,\n                msg: format!(\"{} success\", command.name),\n                data: None,\n            })\n        }\n        None =\u003e Ok(entity::Response {\n            code: 40000,\n            msg: format!(\"{} failed\", command.name),\n            data: None,\n        }),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command","stop.rs"],"content":"use std::{env, error::Error, process::Stdio};\n\nuse tokio::process::{Child, Command};\n\nuse crate::{\n    entity,\n    global::{\n        get_task_by_id, get_task_by_name, get_task_by_pid, update_pid_by_name,\n        update_status_by_name,\n    },\n};\n\npub async fn kill_process(pid: u32) -\u003e Result\u003ci32, Box\u003cdyn Error\u003e\u003e {\n    let env_path = env::var(\"PATH\")?;\n    let mut child: Child = Command::new(\"kill\")\n        .arg(\"-9\")\n        .arg(pid.to_string())\n        .env(\"PATH\", env_path)\n        .stdin(Stdio::null())\n        .stdout(Stdio::null())\n        .stderr(Stdio::null())\n        .spawn()?;\n    let res_exit = child.wait().await;\n    let code = match res_exit {\n        Ok(exit) =\u003e exit.code().unwrap_or(0),\n        Err(_) =\u003e -1,\n    };\n    Ok(code)\n}\n\npub async fn stop_task(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let task;\n    if command.options.contains_key(\"id\") {\n        let id = command.options.get(\"id\").unwrap();\n        if let entity::Opt::U128(ref i) = id {\n            task = get_task_by_id(*i).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'id' must be a usize\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"name\") {\n        let name = command.options.get(\"name\").unwrap();\n        if let entity::Opt::Str(ref s) = name {\n            task = get_task_by_name(s.clone()).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'name' must be a string\".to_string(),\n                data: None,\n            });\n        }\n    } else if command.options.contains_key(\"pid\") {\n        let name = command.options.get(\"pid\").unwrap();\n        if let entity::Opt::U32(ref s) = name {\n            task = get_task_by_pid(*s).await?;\n        } else {\n            return Ok(entity::Response {\n                code: 50000,\n                msg: \"Arg 'pid' must be a number\".to_string(),\n                data: None,\n            });\n        }\n    } else {\n        if command.args.len() == 0 {\n            return Ok(entity::Response {\n                code: 40000,\n                msg: \"Arg 'name' or 'pid' is required\".to_string(),\n                data: None,\n            });\n        } else {\n            task = get_task_by_name(command.args[0].clone()).await?;\n        }\n    }\n\n    if task.status != \"running\" {\n        return Ok(entity::Response {\n            code: 40000,\n            msg: \"Task is not running\".to_string(),\n            data: None,\n        });\n    }\n\n    let pid = task.pid;\n\n    if pid \u003c= 3 {\n        let res = entity::Response {\n            code: 10000,\n            msg: format!(\"{} success\", command.name),\n            data: None,\n        };\n        return Ok(res);\n    }\n\n    let res = match kill_process(pid).await {\n        Ok(code) =\u003e code,\n        Err(_) =\u003e -1,\n    };\n    if res == 0 {\n        update_status_by_name(task.name.clone(), \"stopped\".to_string()).await?;\n        update_pid_by_name(task.name, 0).await?;\n        let res = entity::Response {\n            code: 10000,\n            msg: format!(\"{} success\", command.name),\n            data: None,\n        };\n        return Ok(res);\n    }\n    let res = entity::Response {\n        code: 40000,\n        msg: \"failed\".to_string(),\n        data: None,\n    };\n    return Ok(res);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","command.rs"],"content":"pub mod add;\npub mod exit;\npub mod list;\npub mod pause;\npub mod restart;\npub mod resume;\npub mod run;\npub mod start;\npub mod stop;\n\nuse std::error::Error;\n\nuse chrono::Local;\n\nuse crate::{\n    command,\n    entity::{self, Task},\n    utils::get_id,\n};\n\npub async fn handle_exec(command: entity::Command) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    crate::info!(\"COMMAND\\t{:?}\", command);\n    match command.name.as_str() {\n        \"terminated\" =\u003e {\n            return Ok(entity::Response {\n                code: 10,\n                msg: \"Daemon terminated.\".to_string(),\n                data: None,\n            });\n        }\n        \"run\" =\u003e {\n            let id = crate::utils::get_millis().await;\n            let mut task: Task = Task {\n                id: id,\n                name: command.name,\n                command: command.args[0].clone(),\n                args: command.args[1..].to_vec(),\n                status: \"running\".to_string(),\n                pid: 0,\n                created_at: 0,\n                started_at: 0,\n                exited_at: 0,\n                stopped_at: 0,\n                laststart_at: 0,\n                exit_code: 100,\n                interval: id,\n                origin: 0,\n                timing: Vec::new(),\n            };\n\n            if command.options.contains_key(\"name\") {\n                let name = command.options.get(\"name\").unwrap();\n                match name {\n                    entity::Opt::Str(ref s) =\u003e {\n                        task.name = s.clone();\n                    }\n                    _ =\u003e {\n                        return Ok(entity::Response {\n                            code: 50000,\n                            msg: \"Arg 'name' must be a string\".to_string(),\n                            data: None,\n                        });\n                    }\n                }\n            } else {\n                task.name = get_id().await;\n            }\n\n            if command.options.contains_key(\"origin\") {\n                let origin = command.options.get(\"origin\").unwrap();\n                match origin {\n                    entity::Opt::U128(ref o) =\u003e {\n                        task.origin = *o;\n                    }\n                    _ =\u003e {\n                        return Ok(entity::Response {\n                            code: 50000,\n                            msg: \"Arg 'origin' must be a number\".to_string(),\n                            data: None,\n                        });\n                    }\n                }\n            } else {\n                task.origin = 0;\n            }\n\n            if command.options.contains_key(\"interval\") {\n                let interval = command.options.get(\"interval\").unwrap();\n                match interval {\n                    entity::Opt::U128(ref i) =\u003e {\n                        task.interval = *i;\n                        task.status = \"interval\".to_string();\n                    }\n                    _ =\u003e {\n                        return Ok(entity::Response {\n                            code: 50000,\n                            msg: \"Arg 'interval' must be a number\".to_string(),\n                            data: None,\n                        });\n                    }\n                }\n            } else {\n                task.interval = 0;\n            }\n\n            task.command = command.args[0].clone();\n            task.args = command.args[1..].to_vec();\n\n            let result = command::run::run_task(task).await?;\n            return Ok(result);\n        }\n        \"add\" =\u003e {\n            let id = crate::utils::get_millis().await;\n            let mut task: Task = Task {\n                id: id,\n                name: command.name,\n                command: command.args[0].clone(),\n                args: command.args[1..].to_vec(),\n                status: \"added\".to_string(),\n                pid: 0,\n                created_at: 0,\n                started_at: 0,\n                exited_at: 0,\n                stopped_at: 0,\n                laststart_at: 0,\n                exit_code: 100,\n                interval: 0,\n                origin: 0,\n                timing: Vec::new(),\n            };\n\n            if command.options.contains_key(\"name\") {\n                let name = command.options.get(\"name\").unwrap();\n                match name {\n                    entity::Opt::Str(ref s) =\u003e {\n                        task.name = s.clone();\n                    }\n                    _ =\u003e {\n                        return Ok(entity::Response {\n                            code: 50000,\n                            msg: \"Arg 'name' must be a string\".to_string(),\n                            data: None,\n                        });\n                    }\n                }\n            } else {\n                task.name = get_id().await;\n            }\n\n            if command.options.contains_key(\"origin\") {\n                let origin = command.options.get(\"origin\").unwrap();\n                match origin {\n                    entity::Opt::U128(ref o) =\u003e {\n                        task.origin = *o;\n                    }\n                    _ =\u003e {\n                        return Ok(entity::Response {\n                            code: 50000,\n                            msg: \"Arg 'origin' must be a number\".to_string(),\n                            data: None,\n                        });\n                    }\n                }\n            }\n\n            if command.options.contains_key(\"interval\") {\n                let interval = command.options.get(\"interval\").unwrap();\n                match interval {\n                    entity::Opt::U128(ref i) =\u003e {\n                        task.interval = *i;\n                        task.status = \"interval\".to_string();\n                    }\n                    _ =\u003e {\n                        return Ok(entity::Response {\n                            code: 50000,\n                            msg: \"Arg 'interval' must be a number\".to_string(),\n                            data: None,\n                        });\n                    }\n                }\n            }\n\n            if command.options.contains_key(\"timing\") {\n                let timing = command.options.get(\"timing\").unwrap();\n                match timing {\n                    entity::Opt::U128s(i) =\u003e {\n                        task.timing = i.clone();\n                        task.status = \"timing\".to_string();\n                    }\n                    _ =\u003e {\n                        return Ok(entity::Response {\n                            code: 50000,\n                            msg: \"Arg 'timing' must be a number array\".to_string(),\n                            data: None,\n                        });\n                    }\n                }\n            }\n\n            task.command = command.args[0].clone();\n            task.args = command.args[1..].to_vec();\n\n            let result = command::add::add_a_task(task).await?;\n            return Ok(result);\n        }\n        \"exit\" =\u003e {\n            let result = command::exit::exit_task(command).await;\n            match result {\n                Ok(res) =\u003e {\n                    return Ok(res);\n                }\n                Err(e) =\u003e {\n                    let res = entity::Response {\n                        code: 40000,\n                        msg: e.to_string(),\n                        data: None,\n                    };\n                    return Ok(res);\n                }\n            }\n        }\n        \"start\" =\u003e {\n            let result = command::start::start_task(command).await;\n            match result {\n                Ok(res) =\u003e {\n                    return Ok(res);\n                }\n                Err(e) =\u003e {\n                    let res = entity::Response {\n                        code: 40000,\n                        msg: e.to_string(),\n                        data: None,\n                    };\n                    return Ok(res);\n                }\n            }\n        }\n        \"restart\" =\u003e {\n            let result = command::restart::restart_task(command).await;\n            match result {\n                Ok(res) =\u003e {\n                    return Ok(res);\n                }\n                Err(e) =\u003e {\n                    let res = entity::Response {\n                        code: 40000,\n                        msg: e.to_string(),\n                        data: None,\n                    };\n                    return Ok(res);\n                }\n            }\n        }\n        \"stop\" =\u003e {\n            let result = command::stop::stop_task(command).await;\n            match result {\n                Ok(res) =\u003e {\n                    return Ok(res);\n                }\n                Err(e) =\u003e {\n                    let res = entity::Response {\n                        code: 40000,\n                        msg: e.to_string(),\n                        data: None,\n                    };\n                    return Ok(res);\n                }\n            }\n        }\n        \"pause\" =\u003e {\n            let result = command::pause::pause_task(command).await;\n            match result {\n                Ok(res) =\u003e {\n                    return Ok(res);\n                }\n                Err(e) =\u003e {\n                    let res = entity::Response {\n                        code: 40000,\n                        msg: e.to_string(),\n                        data: None,\n                    };\n                    return Ok(res);\n                }\n            }\n        }\n        \"resume\" =\u003e {\n            let result = command::resume::resume_task(command).await;\n            match result {\n                Ok(res) =\u003e {\n                    return Ok(res);\n                }\n                Err(e) =\u003e {\n                    let res = entity::Response {\n                        code: 40000,\n                        msg: e.to_string(),\n                        data: None,\n                    };\n                    return Ok(res);\n                }\n            }\n        }\n        \"list\" =\u003e {\n            let result = command::list::list_tasks(command).await;\n            match result {\n                Ok(res) =\u003e {\n                    return Ok(res);\n                }\n                Err(e) =\u003e {\n                    let res = entity::Response {\n                        code: 40000,\n                        msg: e.to_string(),\n                        data: None,\n                    };\n                    return Ok(res);\n                }\n            }\n        }\n        _ =\u003e Ok(entity::Response {\n            code: 40000,\n            msg: format!(\"unknown command: {:?}\", command),\n            data: None,\n        }),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","entity.rs"],"content":"use std::collections::HashMap;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Task {\n    pub id: u128,\n    pub name: String,\n    pub command: String,\n    pub args: Vec\u003cString\u003e,\n    pub status: String,\n    pub pid: u32,\n    pub created_at: u128,\n    pub started_at: u128,\n    pub exited_at: u128,\n    pub stopped_at: u128,\n    pub laststart_at: u128,\n    pub exit_code: u32,\n    pub interval: u128,\n    pub origin: u128,\n    pub timing: Vec\u003cu128\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub enum Opt {\n    U128(u128),\n    U128s(Vec\u003cu128\u003e),\n    U32(u32),\n    Str(String),\n    None,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Command {\n    pub name: String,\n    pub options: HashMap\u003cString, Opt\u003e,\n    pub args: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Request {\n    pub name: String,\n    pub command: Command,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub enum Data {\n    TaskList(Vec\u003cTask\u003e),\n    None,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Response {\n    pub code: u32,\n    pub msg: String,\n    pub data: Option\u003cData\u003e,\n}\n\nimpl Response {\n    pub fn new(code: u32, msg: String, data: Option\u003cData\u003e) -\u003e Self {\n        Self { code, msg, data }\n    }\n\n    pub fn ok\u003cT: ToString\u003e(msg: T) -\u003e Self {\n        Self {\n            code: 10000,\n            msg: msg.to_string(),\n            data: None,\n        }\n    }\n\n    pub fn data\u003cT: ToString\u003e(msg: T, data: Option\u003cData\u003e) -\u003e Self {\n        Self {\n            code: 10000,\n            msg: msg.to_string(),\n            data: data,\n        }\n    }\n\n    pub fn err\u003cT: ToString\u003e(msg: T) -\u003e Self {\n        Self {\n            code: 40000,\n            msg: msg.to_string(),\n            data: None,\n        }\n    }\n\n    pub fn f\u003cT: ToString\u003e(msg: T) -\u003e Self {\n        Self {\n            code: 40000,\n            msg: msg.to_string(),\n            data: None,\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","lib.rs"],"content":"pub mod command;\npub mod entity;\npub mod macros;\npub mod monitor;\npub mod socket;\npub mod utils;\n\npub mod global {\n    use std::{error::Error, fs::File, path::Path};\n\n    use lazy_static::lazy_static;\n    use serde_json;\n    use tokio::sync::Mutex;\n\n    use crate::{\n        command::start::{self},\n        entity::Task,\n    };\n\n    lazy_static! {\n        static ref TASKS: Mutex\u003cVec\u003cTask\u003e\u003e = Mutex::new(Vec::new());\n    }\n\n    pub async fn save_tasks(tasks: Vec\u003cTask\u003e) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let args: Vec\u003cString\u003e = std::env::args().collect();\n        if args.len() \u003c 4 {\n            return Err(\"Command line args error\".into());\n        }\n        let home_path = args[2].clone();\n\n        let path = Path::new(\u0026home_path);\n        let path = path.join(\"tasks.json\");\n        match File::create(path) {\n            Ok(f) =\u003e match serde_json::to_writer_pretty(f, \u0026tasks) {\n                _ =\u003e Ok(()),\n            },\n            Err(_) =\u003e Ok(()),\n        }\n    }\n\n    pub async fn load_tasks(home_path: String) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let path = Path::new(\u0026home_path);\n        let path = path.join(\"tasks.json\");\n\n        if path.exists() \u0026\u0026 path.is_file() {\n            let f = File::open(path).unwrap();\n            let data: Vec\u003cTask\u003e = serde_json::from_reader(f).unwrap();\n            let mut tasks = TASKS.lock().await;\n            *tasks = data.clone();\n\n            // 释放锁, 启动 task 时需要更改 task 状态, 需要获取锁\n            drop(tasks);\n\n            for task in data {\n                if task.status == \"running\" {\n                    match start::start_task_by_task(task.clone()).await {\n                        Ok(_) =\u003e {}\n                        Err(_) =\u003e {}\n                    };\n                }\n            }\n        }\n        Ok(())\n    }\n\n    pub async fn check_exists(name: String) -\u003e Result\u003cbool, Box\u003cdyn Error\u003e\u003e {\n        let tasks = get_all_tasks().await?;\n        for task in tasks.iter() {\n            if task.name == name {\n                return Ok(true);\n            }\n        }\n        Ok(false)\n    }\n\n    pub async fn get_task_by_id(id: u128) -\u003e Result\u003cTask, Box\u003cdyn Error\u003e\u003e {\n        let tasks = get_all_tasks().await?;\n        for task in tasks.iter() {\n            if task.id == id {\n                return Ok(task.clone());\n            }\n        }\n        let err = format!(\"Task id '{}' not found\", id);\n        return Err(err.into());\n    }\n\n    pub async fn get_task_by_name(name: String) -\u003e Result\u003cTask, Box\u003cdyn Error\u003e\u003e {\n        let tasks = get_all_tasks().await?;\n        for task in tasks.iter() {\n            if task.name == name {\n                return Ok(task.clone());\n            }\n        }\n        let err = format!(\"Task named '{}' not found\", name);\n        return Err(err.into());\n    }\n\n    pub async fn get_task_by_pid(pid: u32) -\u003e Result\u003cTask, Box\u003cdyn Error\u003e\u003e {\n        let tasks = TASKS.lock().await;\n        for task in tasks.iter() {\n            if task.pid == pid {\n                return Ok(task.clone());\n            }\n        }\n        let err = format!(\"Task pid is '{}' not found\", pid);\n        return Err(err.into());\n    }\n\n    pub async fn get_all_tasks() -\u003e Result\u003cVec\u003cTask\u003e, Box\u003cdyn Error\u003e\u003e {\n        let tasks = TASKS.lock().await;\n        Ok(tasks.to_vec())\n    }\n\n    pub async fn remove_task_by_id(id: u128) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let mut index = 0;\n        for (i, task) in tasks.iter().enumerate() {\n            if task.id == id {\n                index = i;\n                break;\n            }\n        }\n        tasks.remove(index);\n        save_tasks(tasks.clone()).await?;\n        Ok(())\n    }\n\n    pub async fn remove_task_by_name(name: String) -\u003e Result\u003cOption\u003cTask\u003e, Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.name == name);\n        if let Some(pos) = pos {\n            let res = tasks.remove(pos);\n            save_tasks(tasks.clone()).await?;\n            return Ok(Some(res));\n        }\n        Ok(None)\n    }\n\n    pub async fn remove_task_by_pid(pid: u32) -\u003e Result\u003cOption\u003cTask\u003e, Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.pid == pid);\n        if let Some(pos) = pos {\n            let res = tasks.remove(pos);\n            save_tasks(tasks.clone()).await?;\n            return Ok(Some(res));\n        }\n        Ok(None)\n    }\n\n    pub async fn add_task(task: Task) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let timestamp = crate::utils::get_millis().await;\n        let task = Task {\n            created_at: timestamp,\n            ..task\n        };\n        tasks.push(task);\n        save_tasks(tasks.clone()).await?;\n        Ok(())\n    }\n\n    pub async fn update_pid_by_name(name: String, pid: u32) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.name == name);\n        if let Some(pos) = pos {\n            tasks[pos].pid = pid;\n            save_tasks(tasks.clone()).await?;\n        }\n        Ok(())\n    }\n\n    pub async fn update_status_by_name(name: String, status: String) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.name == name);\n        if let Some(pos) = pos {\n            tasks[pos].status = status;\n            save_tasks(tasks.clone()).await?;\n        }\n        Ok(())\n    }\n\n    pub async fn update_started_at_by_id(id: u128, started_at: u128) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.id == id);\n        if let Some(pos) = pos {\n            tasks[pos].started_at = started_at;\n            save_tasks(tasks.clone()).await?;\n        }\n        Ok(())\n    }\n\n    pub async fn update_exited_at_by_id(id: u128, exited_at: u128) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.id == id);\n        if let Some(pos) = pos {\n            tasks[pos].exited_at = exited_at;\n            save_tasks(tasks.clone()).await?;\n        }\n        Ok(())\n    }\n\n    pub async fn update_stopped_at_by_id(id: u128, stopped_at: u128) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.id == id);\n        if let Some(pos) = pos {\n            tasks[pos].stopped_at = stopped_at;\n            save_tasks(tasks.clone()).await?;\n        }\n        Ok(())\n    }\n\n    pub async fn update_laststart_at_by_id(\n        id: u128,\n        laststart_at: u128,\n    ) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.id == id);\n        if let Some(pos) = pos {\n            tasks[pos].laststart_at = laststart_at;\n            save_tasks(tasks.clone()).await?;\n        }\n        Ok(())\n    }\n\n    pub async fn update_exit_code_by_name(\n        name: String,\n        exit_code: u32,\n    ) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        let mut tasks = TASKS.lock().await;\n        let pos = tasks.iter().position(|task| task.name == name);\n        if let Some(pos) = pos {\n            tasks[pos].exit_code = exit_code;\n            save_tasks(tasks.clone()).await?;\n        }\n        Ok(())\n    }\n}\n\npub mod constants {\n    pub enum ExitCode {\n        SUCCESS = 0,\n        ERROR = 255,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","macros.rs"],"content":"#[macro_export]\nmacro_rules! info {\n    ($($arg:tt)*) =\u003e {\n        let dft = Local::now().to_string();\n        println!(\"[INFO]\\t{}\\t{}\", dft, format_args!($($arg)*));\n    };\n}\n\n#[macro_export]\nmacro_rules! error {\n    ($($arg:tt)*) =\u003e {\n        let dft = Local::now().to_string();\n        eprintln!(\"[ERROR]\\t{}\\t{}\", dft, format_args!($($arg)*));\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","main.rs"],"content":"use std::{error::Error, fs::remove_file, path::Path, process::exit};\nuse tokio::sync::mpsc;\n\nuse daemon::monitor::run_monitor;\nuse daemon::socket::run_socket;\n\nuse logger::{self, log};\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    let args: Vec\u003cString\u003e = std::env::args().collect();\n    // args[0]: daemon\n    // args[1]: sock_path\n    // args[2]: home_path\n    // args[3]: stdout_path\n    if args.len() \u003c 4 {\n        eprintln!(\"Exit code: 255 =\u003e Missing path argument.\");\n        exit(255);\n    }\n\n    let mut l = logger::Logger::new(\n        logger::Level::Info,\n        String::from(\"[L]\\t[T]\\t[M]\"),\n        String::from(args[2].clone()),\n        String::from(\"daemon\"),\n        1024 * 1024 * 10,\n    );\n\n    let home_path = args[2].clone();\n\n    // 加载上次运行的任务\n    let tasks_result = daemon::global::load_tasks(home_path.clone()).await;\n    if tasks_result.is_err() {\n        log!(l, error, \"Exit code: 254 =\u003e {}\", tasks_result.err().unwrap());\n        exit(254);\n    }\n    let mut ll = l.clone();\n    let monitor = tokio::spawn(async move {\n        match run_monitor(home_path).await {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                log!(ll, error, \"Exit code: 253 =\u003e {}\", e);\n                exit(253);\n            }\n        }\n    });\n\n    let path = args[1].clone();\n\n    // 新线程运行 run_socket\n    let p1 = path.clone();\n    let socket = tokio::spawn(async move {\n        run_socket(\u0026p1).await.unwrap();\n    });\n\n    // 协程间通信 / channel, 监听 ctrl c 和 ctrl d 信号 / listen ctrl-c and ctrl-d signal\n    let (tx, mut rx) = mpsc::channel::\u003ci32\u003e(12);\n\n    let tx1 = tx.clone(); // 监听到 ctrl c 通信管道\n    let tx2 = tx.clone(); // 监听到 ctrl d 通信管道\n\n    // ctrl c 停止运行 / terminate on ctrl-c\n    let signal1 = tokio::spawn(async move {\n        tokio::signal::ctrl_c().await.unwrap();\n        tx1.send(9).await.unwrap();\n    });\n\n    // ctrl d 停止运行 / terminate on ctrl-d\n    let signal2 = tokio::spawn(async move {\n        tokio::signal::unix::signal(tokio::signal::unix::SignalKind::terminate())\n            .unwrap()\n            .recv()\n            .await;\n        tx2.send(15).await.unwrap();\n    });\n\n    // 等待停止信号 / wait for stop signal\n    let res = rx.recv().await;\n\n    signal1.abort();\n    signal2.abort();\n    monitor.abort();\n    socket.abort();\n\n    // 删除 sock 文件 / remove sock file\n    let p2 = path.clone();\n    let sock_path = Path::new(\u0026p2);\n    remove_file(sock_path).unwrap_or_default();\n\n    if let Some(code) = res {\n        log!(l, info, \"Exit code: {} =\u003e exited\", code);\n        exit(code);\n    } else {\n        log!(l, info, \"Exit code: 0 =\u003e exited\");\n        exit(0);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use logger;\n\n    #[test]\n    fn test() {\n        let mut log = logger::Logger::new(\n            logger::Level::Info,\n            String::from(\"[T]\\t[L]\\t[M]\"),\n            String::from(\"/tmp/watchmen/\"),\n            String::from(\"daemon\"),\n            1024,\n        );\n\n        log.info(\"test\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","monitor.rs"],"content":"use chrono::prelude::{DateTime, Local};\nuse std::{env, path::Path, process::Stdio, time::Duration};\nuse tokio::{\n    process::{Child, Command},\n    time,\n};\n\nuse crate::{\n    entity,\n    global::{get_all_tasks, update_laststart_at_by_id},\n};\n\npub async fn rerun_tasks(home_path: String) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let tasks = get_all_tasks().await?;\n    for task in tasks {\n        let time: DateTime\u003cLocal\u003e = Local::now();\n        let now = time.timestamp_millis() as u128;\n\n        if task.status == \"interval\" \u0026\u0026 now \u003e= task.origin {\n            if now - task.laststart_at \u003c task.interval {\n                continue;\n            }\n\n            // 声明指向文件的 stdout\n            let path = Path::new(\u0026home_path);\n            let path = path.join(\"stdout\");\n            let path = path.join(format!(\"{}.log\", task.name));\n\n            // 创建或追加文件\n            let file = std::fs::OpenOptions::new()\n                .create(true)\n                .append(true)\n                .open(path)?;\n            let stdout = Stdio::from(file);\n\n            crate::info!(\"TASK\\tEXECUTE\\t{:?}\", task);\n\n            // 获取环境变量 PATH\n            let env_path = env::var(\"PATH\")?;\n            let mut child: Child = Command::new(\u0026task.command)\n                .args(\u0026task.args)\n                .env(\"PATH\", env_path)\n                .stdin(Stdio::null())\n                .stdout(stdout)\n                .stderr(Stdio::null())\n                .spawn()?;\n\n            let result = child.id();\n            if result.is_some() {\n                update_laststart_at_by_id(task.id, now).await?;\n                tokio::spawn(async move {\n                    let s = child.wait().await.unwrap();\n                    let exit_code = s.code().unwrap_or(-1);\n                    crate::info!(\"TASK\\tFINISH\\t{}\\t{:?}\", exit_code, task);\n                });\n            }\n        }\n    }\n    Ok(())\n}\n\npub async fn run_monitor(\n    home_path: String,\n) -\u003e Result\u003centity::Response, Box\u003cdyn std::error::Error\u003e\u003e {\n    let mut interval = time::interval(Duration::from_secs(2));\n    loop {\n        match rerun_tasks(home_path.clone()).await {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                crate::error!(\"Monitor tasks error: {}\", e);\n            }\n        }\n        interval.tick().await;\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","socket.rs"],"content":"use chrono::Local;\nuse std::{error::Error, fs::remove_file, path::Path, process::exit};\nuse tokio::{\n    io::{AsyncReadExt, AsyncWriteExt},\n    net::{UnixListener, UnixStream},\n};\n\nuse crate::{command, entity};\n\nasync fn handle_connection(mut stream: UnixStream) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    let (mut reader, mut writer) = stream.split();\n    let mut buf: [u8; 1024] = [0; 1024];\n    let n = reader.read(\u0026mut buf).await?;\n\n    let req: entity::Request = serde_json::from_slice(\u0026buf[..n])?;\n\n    let res = command::handle_exec(req.command).await?;\n\n    writer.write_all(\u0026serde_json::to_vec(\u0026res)?).await?;\n\n    if res.code == 10 {\n        let args: Vec\u003cString\u003e = std::env::args().collect();\n        let path = args[1].clone();\n        let sock_path = Path::new(\u0026path);\n        remove_file(sock_path).unwrap_or_default();\n        exit(0);\n    }\n    Ok(())\n}\n\npub async fn run_socket(path: \u0026String) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    let sock_path = Path::new(path);\n    remove_file(sock_path).unwrap_or_default();\n\n    // 创建监听器 / create a listener\n    let listener = UnixListener::bind(path);\n\n    match listener {\n        Ok(listener) =\u003e {\n            crate::info!(\"Listening\\t{:?}\", listener.local_addr().unwrap());\n\n            loop {\n                // 等待连接 / wait connection\n                match listener.accept().await {\n                    Ok((stream, _addr)) =\u003e {\n                        // 处理连接 / handle connection\n                        tokio::spawn(async move {\n                            if let Err(e) = handle_connection(stream).await {\n                                eprintln!(\"failed to process connection: {}\", e);\n                            }\n                        });\n                    }\n                    Err(e) =\u003e {\n                        eprintln!(\"failed to accept socket; error = {:?}\", e);\n                    }\n                }\n            }\n        }\n        Err(e) =\u003e {\n            eprintln!(\"{}: {}\", Local::now(), e);\n            exit(1);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","daemon","src","utils.rs"],"content":"use nanoid::nanoid;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\npub async fn get_id() -\u003e String {\n    let alphabet: [char; 62] = [\n        '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\n        'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',\n        'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    ];\n    nanoid!(10, \u0026alphabet)\n}\n\npub async fn get_millis() -\u003e u128 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .unwrap()\n        .as_millis()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","guard","src","main.rs"],"content":"use std::{\n    env,\n    error::Error,\n    fs::remove_file,\n    io::Write,\n    path::Path,\n    process::{exit, Stdio},\n};\n\nuse tokio::process::Command;\n\n#[tokio::main]\nasync fn main() {\n    let args: Vec\u003cString\u003e = env::args().collect();\n    if args.len() \u003c 4 {\n        eprintln!(\"Missing path argument.\");\n        exit(0);\n    }\n\n    let valid_args = args[1..].to_vec();\n\n    loop {\n        match start_daemon(\u0026valid_args).await {\n            Ok(res_code) =\u003e match res_code {\n                10000 =\u003e {\n                    println!(\"Daemon terminated. {}\", res_code);\n                    exit(0);\n                }\n                50000 =\u003e {\n                    println!(\"Unexpected termination of program. {}\", res_code);\n                }\n                _ =\u003e {\n                    eprintln!(\"Unexpected program error. {}\", res_code);\n                }\n            },\n            Err(err) =\u003e {\n                eprintln!(\"{}\", err);\n                break;\n            }\n        }\n    }\n}\n\nasync fn start_daemon(args: \u0026[String]) -\u003e Result\u003ci32, Box\u003cdyn Error\u003e\u003e {\n    let now = chrono::Local::now().format(\"%Y%m%d\").to_string();\n    let path = Path::new(\u0026args[1]);\n    let path_daemon_stdout = path.clone().join(format!(\"daemon_stdout_{}.log\", now));\n    let path_daemon_stderr = path.clone().join(format!(\"daemon_stderr_{}.log\", now));\n    let file_stdout = std::fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(path_daemon_stdout.clone())?;\n    let file_stderr = std::fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(path_daemon_stderr.clone())?;\n    let stdout = Stdio::from(file_stdout);\n    let stderr = Stdio::from(file_stderr);\n\n    let path_daemon = std::env::current_dir()?.join(\"daemon\");\n    // 子进程\n    let mut child = Command::new(path_daemon)\n        .args(args)\n        .stdout(stdout)\n        .stderr(stderr)\n        .spawn()?;\n\n    let result = child.id();\n\n    match result {\n        Some(pid) =\u003e {\n            // 保存 pid\n            let path_watchmen = path.join(\"daemon.pid\");\n            // 创建文件\n            let mut file = std::fs::File::create(path_watchmen.clone())?;\n            // 写入 pid\n            file.write_all(pid.to_string().as_bytes())?;\n\n            let res = child.wait().await.unwrap();\n            remove_file(path_watchmen).unwrap_or_default();\n\n            if res.success() {\n                let path_guard = path.join(\"guard.pid\");\n                remove_file(path_guard).unwrap_or_default();\n                return Ok(10000);\n            } else {\n                return Ok(50000);\n            }\n        }\n        None =\u003e Ok(-1),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","library","logger","src","lib.rs"],"content":"use std::{fs::File, io::Write};\n\n#[derive(Clone)]\npub enum Level {\n    Debug = 0,\n    Info = 1,\n    Warn = 2,\n    Error = 3,\n}\n\n#[derive(Clone)]\npub struct Logger {\n    level: Level,\n    format: String,\n    path: String,\n    filename: String,\n    max_size: u64,\n}\n\nimpl Logger {\n    pub fn new(\n        level: Level,\n        format: String,\n        path: String,\n        filename: String,\n        max_size: u64,\n    ) -\u003e Self {\n        Self {\n            level,\n            format,\n            path,\n            filename,\n            max_size,\n        }\n    }\n\n    fn f(\u0026mut self) -\u003e File {\n        let file: File;\n        let mut index = 1;\n        loop {\n            let log_file_name = format!(\n                \"{}_{}_{}.log\",\n                self.filename,\n                chrono::Local::now().format(\"%Y%m%d\").to_string(),\n                index\n            );\n            let file_path = std::path::Path::new(\u0026self.path).join(log_file_name);\n            if file_path.exists() {\n                let file_size = std::fs::metadata(file_path.clone()).unwrap().len();\n                if file_size \u003e= self.max_size {\n                    index += 1;\n                    continue;\n                } else {\n                    file = std::fs::OpenOptions::new()\n                        .create(true)\n                        .append(true)\n                        .open(file_path.clone())\n                        .unwrap();\n                    break;\n                }\n            } else {\n                file = std::fs::OpenOptions::new()\n                    .create(true)\n                    .append(true)\n                    .open(file_path.clone())\n                    .unwrap();\n                break;\n            }\n        }\n        return file;\n    }\n\n    fn w(\u0026mut self, msg: \u0026str, level: Level) {\n        let mut file = self.f();\n\n        /*\n         * [T] - 时间\n         * [L] - 日志级别\n         * [M] - 日志内容\n         */\n        let t = chrono::Local::now().format(\"[%Y-%m-%d %H:%M:%S]\");\n        let l = match level {\n            Level::Debug =\u003e \"[Debug]\",\n            Level::Info =\u003e \"[Info]\",\n            Level::Warn =\u003e \"[Warn]\",\n            Level::Error =\u003e \"[Error]\",\n        };\n        let message: String = self\n            .format\n            .replace(\"[T]\", \u0026t.to_string())\n            .replace(\"[L]\", l)\n            .replace(\"[M]\", \u0026msg);\n\n        let message = format!(\"{}\\n\", message);\n\n        file.write_all(message.as_bytes()).unwrap();\n    }\n\n    pub fn debug(\u0026mut self, msg: \u0026str) {\n        self.w(msg, Level::Debug);\n    }\n\n    pub fn info(\u0026mut self, msg: \u0026str) {\n        match self.level {\n            Level::Info =\u003e self.w(msg, Level::Info),\n            Level::Warn =\u003e self.w(msg, Level::Info),\n            Level::Error =\u003e self.w(msg, Level::Info),\n            _ =\u003e return,\n        }\n    }\n\n    pub fn warn(\u0026mut self, msg: \u0026str) {\n        match self.level {\n            Level::Warn =\u003e self.w(msg, Level::Warn),\n            Level::Error =\u003e self.w(msg, Level::Warn),\n            _ =\u003e return,\n        }\n    }\n\n    pub fn error(\u0026mut self, msg: \u0026str) {\n        match self.level {\n            Level::Error =\u003e self.w(msg, Level::Error),\n            _ =\u003e return,\n        }\n    }\n}\n\n#[macro_export]\nmacro_rules! log {\n    ($logger:ident, $level:ident, $($arg:tt)*) =\u003e {\n        $logger.$level(\u0026format!($($arg)*));\n    };\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test() {\n        let mut logger = Logger::new(\n            Level::Debug,\n            \"[T] [L] [M]\".to_string(),\n            \"/tmp/watchmen/\".to_string(),\n            \"test\".to_string(),\n            1024 * 1024 * 10,\n        );\n        log!(logger, debug, \"debug{}\", 1);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","plugins","plugin","src","lib.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[repr(C)]\npub struct Task {\n    pub id: u128,\n    pub name: String,\n    pub command: String,\n    pub args: Vec\u003cString\u003e,\n    pub status: String,\n    pub pid: u32,\n    pub created_at: u128,\n    pub started_at: u128,\n    pub exited_at: u128,\n    pub stopped_at: u128,\n    pub laststart_at: u128,\n    pub exit_code: u32,\n    pub interval: u128,\n    pub origin: u128,\n    pub timing: Vec\u003cu128\u003e,\n}\n\n#[no_mangle]\npub async extern \"C\" fn func_plugin(t: i32) -\u003e bool {\n    print!(\"PRINT FROM PLUGIN: {:?}\", t);\n    false\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","add.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst ADD_HELP: \u0026str = r#\"Usage: watchmen add [OPTION...] ...\n    -h, --help          display this help of 'add' command\n\n    -n, --name          task name, default is a random string\n\n    -o, --origin        recurring task start time\n                        format: YYYYMMDD.HHMMSS | YYYYMMDD | MMDD | MMDD.HHMMSS | HHMMSS\n                        example: 20201231.235959 | 20201231 | 1231 | 1231.235959 | 235959\n\n    -i, --interval      recurring task interval\n                        format: 1d2h3m4s5 | 3m4s5 | 4s5 | 5 ...\n\n    -t, --timing        scheduled Tasks\n                        format: split by ',' YYYYMMDD.HHMMSS | YYYYMMDD | MMDD | MMDD.HHMMSS | HHMMSS\n                        example: 20210101.000000,20210102.000000,20210103\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(ADD_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(ADD_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    if args[1].starts_with(\"-\") {\n                        return Ok(entity::Response::err(format!(\n                            \"Value of '{}' connot start with '-'\",\n                            args[0]\n                        )));\n                    }\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-o\" || args[0] == \"--origin\" {\n                    let mut input = args[1].clone();\n\n                    if !input.contains(\".\") {\n                        input = match input.len() {\n                            4 =\u003e {\n                                // current year\n                                let year = chrono::Local::now().format(\"%Y\").to_string();\n                                format!(\"{}{}.000000\", year, input)\n                            }\n                            8 =\u003e format!(\"{}.000000\", input),\n                            6 =\u003e {\n                                let date = chrono::Local::now().format(\"%Y%m%d\").to_string();\n                                format!(\"{}.{}\", date, input)\n                            }\n                            _ =\u003e {\n                                println!(\"Invalid timestamp: {}\", input);\n                                return Ok(entity::Response::f(format!(\n                                    \"Arg '{}' must be a number\",\n                                    args[0]\n                                )));\n                            }\n                        };\n                    }\n                    if input.len() == 11 {\n                        let year = chrono::Local::now().format(\"%Y\").to_string();\n                        input = format!(\"{}{}\", year, input);\n                    }\n                    let timestamp = chrono::NaiveDateTime::parse_from_str(\u0026input, \"%Y%m%d.%H%M%S\")\n                        .unwrap()\n                        .timestamp_millis() as u128;\n                    options.insert(\"pid\".to_string(), Opt::U128(timestamp));\n                } else if args[0] == \"-i\" || args[0] == \"--interval\" {\n                    let mut ms: u128 = 0;\n                    let mut num: u128 = 0;\n\n                    for c in args[1].chars() {\n                        if c.is_numeric() {\n                            num = num * 10 + c.to_digit(10).unwrap() as u128;\n                        } else {\n                            match c {\n                                'd' =\u003e {\n                                    ms += num * 24 * 60 * 60 * 1000;\n                                }\n                                'h' =\u003e {\n                                    ms += num * 60 * 60 * 1000;\n                                }\n                                'm' =\u003e {\n                                    ms += num * 60 * 1000;\n                                }\n                                's' =\u003e {\n                                    ms += num * 1000;\n                                }\n                                _ =\u003e {\n                                    return Ok(entity::Response::f(format!(\n                                        \"Arg '{}' value invalid unit\",\n                                        args[0]\n                                    )));\n                                }\n                            }\n                            num = 0;\n                        }\n                    }\n                    if num \u003e 999 {\n                        return Ok(entity::Response::f(format!(\n                            \"Arg '{}' value 'ms' must less 1000\",\n                            args[0]\n                        )));\n                    }\n                    ms += num;\n                    options.insert(\"interval\".to_string(), Opt::U128(ms));\n                } else if args[0] == \"-t\" || args[0] == \"--timing\" {\n                    let inputs = args[1].clone();\n                    let mut timestamps: Vec\u003cu128\u003e = Vec::new();\n                    for ipt in inputs.split(\",\") {\n                        let mut input = ipt.to_string();\n                        if !input.contains(\".\") {\n                            input = match input.len() {\n                                4 =\u003e {\n                                    // current year\n                                    let year = chrono::Local::now().format(\"%Y\").to_string();\n                                    format!(\"{}{}.000000\", year, input)\n                                }\n                                8 =\u003e format!(\"{}.000000\", input),\n                                6 =\u003e {\n                                    let date = chrono::Local::now().format(\"%Y%m%d\").to_string();\n                                    format!(\"{}.{}\", date, input)\n                                }\n                                _ =\u003e {\n                                    println!(\"Invalid timestamp: {}\", input);\n                                    return Ok(entity::Response::f(format!(\n                                        \"Arg '{}' must be a number\",\n                                        args[0]\n                                    )));\n                                }\n                            };\n                        }\n                        if input.len() == 11 {\n                            let year = chrono::Local::now().format(\"%Y\").to_string();\n                            input = format!(\"{}{}\", year, input);\n                        }\n                        let timestamp =\n                            chrono::NaiveDateTime::parse_from_str(\u0026input, \"%Y%m%d.%H%M%S\")\n                                .unwrap()\n                                .timestamp_millis() as u128;\n                        timestamps.push(timestamp);\n                    }\n                    options.insert(\"timing\".to_string(), Opt::U128s(timestamps));\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n            let req = entity::Request {\n                name: \"add\".to_string(),\n                command: entity::Command {\n                    name: \"add\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","exit.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst EXIT_HELP: \u0026str = r#\"Usage: watchmen [exit|rm|drop] [OPTION...] ...\n    -h, --help      display this help of 'exit' | 'rm' | 'drop' command\n\n    -i, --id        task id\n    -n, --name      task name\n    -p, --pid       task pid\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(EXIT_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(EXIT_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-p\" || args[0] == \"--pid\" {\n                    let pid = args[1].parse::\u003cu32\u003e();\n                    match pid {\n                        Ok(p) =\u003e {\n                            options.insert(\"pid\".to_string(), Opt::U32(p));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else if args[0] == \"-i\" || args[0] == \"--id\" {\n                    let id = args[1].parse::\u003cu128\u003e();\n                    match id {\n                        Ok(i) =\u003e {\n                            options.insert(\"id\".to_string(), Opt::U128(i));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n\n            let req = entity::Request {\n                name: \"exit\".to_string(),\n                command: entity::Command {\n                    name: \"exit\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","list.rs"],"content":"use chrono::{Local, TimeZone};\nuse colored::Colorize;\nuse std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt, Task},\n    socket,\n};\n\nconst LIST_HELP: \u0026str = r#\"Usage: watchmen list [OPTION...] ...\n    -h, --help      display this help of 'list' command\n\n    -n, --name      tasks name with regular expression\n    -s, --status    task status\n    -p, --pid       task pid\n\n    -m, --more      show more details\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    let mut more = false;\n    if len == 1 {\n        if args[0] == \"-h\" || args[0] == \"--help\" {\n            return Ok(entity::Response::ok(LIST_HELP));\n        } else if args[0] == \"-m\" || args[0] == \"--more\" {\n            more = true;\n        }\n    }\n    let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n    let mut args: Vec\u003cString\u003e = args.to_vec();\n    while args.len() \u003e 1 {\n        if args[0] == \"-n\" || args[0] == \"--name\" {\n            options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n            args.remove(0);\n            args.remove(0);\n        } else if args[0] == \"-s\" || args[0] == \"--status\" {\n            options.insert(\"status\".to_string(), Opt::Str(args[1].clone()));\n            args.remove(0);\n            args.remove(0);\n        } else if args[0] == \"-p\" || args[0] == \"--pid\" {\n            let pid = args[1].parse::\u003cu32\u003e();\n            match pid {\n                Ok(p) =\u003e {\n                    options.insert(\"pid\".to_string(), Opt::U32(p));\n                }\n                Err(_) =\u003e {\n                    return Ok(entity::Response::f(format!(\n                        \"Arg '{}' must be a number\",\n                        args[0]\n                    )));\n                }\n            }\n            args.remove(0);\n            args.remove(0);\n        } else if args[0] == \"-m\" || args[0] == \"--more\" {\n            more = true;\n            args.remove(0);\n        } else {\n            break;\n        }\n    }\n\n    let req = entity::Request {\n        name: \"list\".to_string(),\n        command: entity::Command {\n            name: \"list\".to_string(),\n            options: options,\n            args: args,\n        },\n    };\n    let res = socket::request(\u0026req, home_path).await?;\n    if let Some(data) = res.data {\n        match data {\n            entity::Data::TaskList(tasks) =\u003e print_format(tasks, more).await,\n            _ =\u003e {}\n        }\n    }\n    Ok(entity::Response::ok(\"list success\"))\n}\n\nasync fn print_format(res: Vec\u003cTask\u003e, more: bool) {\n    let sum_all = res.len();\n    let len_id = res\n        .iter()\n        .map(|x| x.id.to_string().len())\n        .max()\n        .unwrap_or_else(|| 0);\n    let len_name = res.iter().map(|x| x.name.len()).max().unwrap_or_else(|| 0);\n    let len_status = res\n        .iter()\n        .map(|x| x.status.len())\n        .max()\n        .unwrap_or_else(|| 0);\n    let len_pid = res\n        .iter()\n        .map(|x| x.pid.to_string().len())\n        .max()\n        .unwrap_or_else(|| 0);\n    let len_created_at = 19;\n    let len_started_at = 19;\n    let len_exited_at = 19;\n    let len_stopped_at = 19;\n    let len_exit_code = 5;\n\n    let title_id = \"ID\".bold();\n    let len_id = if len_id \u003e title_id.len() {\n        len_id\n    } else {\n        title_id.len()\n    };\n    let title_name = \"NAME\".bold();\n    let len_name = if len_name \u003e title_name.len() {\n        len_name\n    } else {\n        title_name.len()\n    };\n    let title_status = \"·STATUS\".bold();\n    let len_status = if len_status \u003e title_status.len() {\n        len_status\n    } else {\n        title_status.len()\n    };\n    let title_pid = \"PID\".bold();\n    let len_pid = if len_pid \u003e title_pid.len() {\n        len_pid\n    } else {\n        title_pid.len()\n    };\n    let title_created_at = \"CREATED_AT\".bold();\n    let len_created_at = if len_created_at \u003e title_created_at.len() {\n        len_created_at\n    } else {\n        title_created_at.len()\n    };\n    let title_started_at = \"STARTED_AT\".bold();\n    let len_started_at = if len_started_at \u003e title_started_at.len() {\n        len_started_at\n    } else {\n        title_started_at.len()\n    };\n    let title_exited_at = \"EXITED_AT\".bold();\n    let len_exited_at = if len_exited_at \u003e title_exited_at.len() {\n        len_exited_at\n    } else {\n        title_exited_at.len()\n    };\n    let title_stopped_at = \"STOPPED_AT\".bold();\n    let len_stopped_at = if len_stopped_at \u003e title_stopped_at.len() {\n        len_stopped_at\n    } else {\n        title_stopped_at.len()\n    };\n    let title_exit_code = \"EXIT_CODE\".bold();\n    let len_exit_code = if len_exit_code \u003e title_exit_code.len() {\n        len_exit_code\n    } else {\n        title_exit_code.len()\n    };\n\n    if more {\n        let len_sum = len_id\n            + len_name\n            + len_status\n            + len_pid\n            + len_created_at\n            + len_started_at\n            + len_exited_at\n            + len_stopped_at\n            + len_exit_code\n            + 9 * 2\n            + 11;\n        println!(\"{:-\u003clen_sum$}\", \"\", len_sum = len_sum);\n        println!(\n            \"| {: \u003clen_id$} | {: \u003clen_name$} | {: \u003clen_status$} | {: \u003clen_pid$} | {: \u003clen_created_at$} | {: \u003clen_started_at$} | {: \u003clen_exited_at$} | {: \u003clen_stopped_at$} | {: \u003clen_exit_code$} |\",\n            title_id, title_name, title_status, title_pid, title_created_at, title_started_at, title_exited_at, title_stopped_at, title_exit_code,\n            len_id = len_id, len_name = len_name, len_status = len_status + 1, len_pid = len_pid, len_created_at = len_created_at, len_started_at = len_started_at, len_exited_at = len_exited_at, len_stopped_at = len_stopped_at, len_exit_code = len_exit_code\n        );\n        let mut sum_running = 0;\n        let mut sum_stopped = 0;\n        let mut sum_waiting = 0;\n        let mut sum_added = 0;\n        let mut sum_interval = 0;\n        println!(\"{:-\u003clen_sum$}\", \"\", len_sum = len_sum);\n        for task in res {\n            let mut ling = \"·\".to_string();\n            if task.status == \"running\" {\n                ling = ling.green().to_string();\n                sum_running += 1;\n            } else if task.status == \"stopped\" {\n                ling = ling.red().to_string();\n                sum_stopped += 1;\n            } else if task.status == \"waiting\" {\n                ling = ling.blue().to_string();\n                sum_waiting += 1;\n            } else if task.status == \"added\" {\n                ling = ling.magenta().to_string();\n                sum_added += 1;\n            } else if task.status == \"interval\" {\n                ling = ling.cyan().to_string();\n                sum_interval += 1;\n            }\n            let created_at = if task.created_at \u003e 0 {\n                Local\n                    .timestamp_millis(task.created_at as i64)\n                    .format(\"%Y-%m-%d %H:%M:%S\")\n                    .to_string()\n            } else {\n                \"\".to_string()\n            };\n            let started_at = if task.started_at \u003e 0 {\n                Local\n                    .timestamp_millis(task.started_at as i64)\n                    .format(\"%Y-%m-%d %H:%M:%S\")\n                    .to_string()\n            } else {\n                \"\".to_string()\n            };\n            let exited_at = if task.exited_at \u003e 0 {\n                Local\n                    .timestamp_millis(task.exited_at as i64)\n                    .format(\"%Y-%m-%d %H:%M:%S\")\n                    .to_string()\n            } else {\n                \"\".to_string()\n            };\n            let stopped_at = if task.stopped_at \u003e 0 {\n                Local\n                    .timestamp_millis(task.stopped_at as i64)\n                    .format(\"%Y-%m-%d %H:%M:%S\")\n                    .to_string()\n            } else {\n                \"\".to_string()\n            };\n            let exit_code = if task.exit_code != 100 {\n                task.exit_code.to_string()\n            } else {\n                \"\".to_string()\n            };\n            println!(\n                \"| {: \u003clen_id$} | {: \u003clen_name$} | {}{: \u003clen_status$} | {: \u003clen_pid$} | {: \u003clen_created_at$} | {: \u003clen_started_at$} | {: \u003clen_exited_at$} | {: \u003clen_stopped_at$} | {: \u003clen_exit_code$} |\",\n                task.id, task.name, ling, task.status, task.pid, created_at, started_at, exited_at, stopped_at, exit_code,\n                len_id = len_id, len_name = len_name, len_status = len_status, len_pid = len_pid, len_created_at = len_created_at, len_started_at = len_started_at, len_exited_at = len_exited_at, len_stopped_at = len_stopped_at, len_exit_code = len_exit_code\n            );\n            println!(\"{:-\u003clen_sum$}\", \"\", len_sum = len_sum);\n        }\n        println!(\n            \"{} Total: {} running, {} stopped, {} added, {} waiting, {} interval\",\n            sum_all,\n            sum_running.to_string().green().to_string(),\n            sum_stopped.to_string().red().to_string(),\n            sum_added.to_string().magenta().to_string(),\n            sum_waiting.to_string().blue().to_string(),\n            sum_interval.to_string().cyan().to_string()\n        );\n    } else {\n        let len_sum = len_id\n            + len_name\n            + len_status\n            + len_pid\n            + len_started_at\n            + len_stopped_at\n            + len_exit_code\n            + 7 * 2\n            + 9;\n        println!(\"{:-\u003clen_sum$}\", \"\", len_sum = len_sum);\n        println!(\n            \"| {: \u003clen_id$} | {: \u003clen_name$} | {: \u003clen_status$} | {: \u003clen_pid$} | {: \u003clen_started_at$} | {: \u003clen_stopped_at$} | {: \u003clen_exit_code$} |\",\n            title_id, title_name, title_status, title_pid, title_started_at, title_stopped_at, title_exit_code,\n            len_id = len_id, len_name = len_name, len_status = len_status + 1, len_pid = len_pid, len_started_at = len_started_at, len_stopped_at = len_stopped_at, len_exit_code = len_exit_code\n        );\n        let mut sum_running = 0;\n        let mut sum_stopped = 0;\n        let mut sum_waiting = 0;\n        let mut sum_added = 0;\n        let mut sum_interval = 0;\n        println!(\"{:-\u003clen_sum$}\", \"\", len_sum = len_sum);\n        for task in res {\n            let mut ling = \"·\".to_string();\n            if task.status == \"running\" {\n                ling = ling.green().to_string();\n                sum_running += 1;\n            } else if task.status == \"stopped\" {\n                ling = ling.red().to_string();\n                sum_stopped += 1;\n            } else if task.status == \"waiting\" {\n                ling = ling.blue().to_string();\n                sum_waiting += 1;\n            } else if task.status == \"added\" {\n                ling = ling.magenta().to_string();\n                sum_added += 1;\n            } else if task.status == \"interval\" {\n                ling = ling.cyan().to_string();\n                sum_interval += 1;\n            }\n            let started_at = if task.started_at \u003e 0 {\n                Local\n                    .timestamp_millis(task.started_at as i64)\n                    .format(\"%Y-%m-%d %H:%M:%S\")\n                    .to_string()\n            } else {\n                \"\".to_string()\n            };\n            let stopped_at = if task.stopped_at \u003e 0 {\n                Local\n                    .timestamp_millis(task.stopped_at as i64)\n                    .format(\"%Y-%m-%d %H:%M:%S\")\n                    .to_string()\n            } else {\n                \"\".to_string()\n            };\n            let exit_code = if task.exit_code != 100 {\n                task.exit_code.to_string()\n            } else {\n                \"\".to_string()\n            };\n            println!(\n                \"| {: \u003clen_id$} | {: \u003clen_name$} | {}{: \u003clen_status$} | {: \u003clen_pid$} | {: \u003clen_started_at$} | {: \u003clen_stopped_at$} | {: \u003clen_exit_code$} |\",\n                task.id, task.name, ling, task.status, task.pid, started_at, stopped_at, exit_code,\n                len_id = len_id, len_name = len_name, len_status = len_status, len_pid = len_pid, len_started_at = len_started_at, len_stopped_at = len_stopped_at, len_exit_code = len_exit_code\n            );\n            println!(\"{:-\u003clen_sum$}\", \"\", len_sum = len_sum);\n        }\n        println!(\n            \"{} Total: {} running, {} stopped, {} added, {} waiting, {} interval\",\n            sum_all,\n            sum_running.to_string().green().to_string(),\n            sum_stopped.to_string().red().to_string(),\n            sum_added.to_string().magenta().to_string(),\n            sum_waiting.to_string().blue().to_string(),\n            sum_interval.to_string().cyan().to_string()\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","pause.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst PAUSE_HELP: \u0026str = r#\"Usage: watchmen pause [OPTION...] ...\n    -h, --help     display this help of 'pause' command\n\n    -i, --id       task id\n    -n, --name     task name\n    -p, --pid      task pid\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(PAUSE_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(PAUSE_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-p\" || args[0] == \"--pid\" {\n                    let pid = args[1].parse::\u003cu32\u003e();\n                    match pid {\n                        Ok(p) =\u003e {\n                            options.insert(\"pid\".to_string(), Opt::U32(p));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else if args[0] == \"-i\" || args[0] == \"--id\" {\n                    let id = args[1].parse::\u003cu128\u003e();\n                    match id {\n                        Ok(i) =\u003e {\n                            options.insert(\"id\".to_string(), Opt::U128(i));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n\n            let req = entity::Request {\n                name: \"pause\".to_string(),\n                command: entity::Command {\n                    name: \"pause\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","restart.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst RESTART_HELP: \u0026str = r#\"Usage: watchmen restart [OPTION...] ...\n    -h, --help      display this help of 'restart' command\n\n    -i, --id        task id\n    -n, --name      task name\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(RESTART_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(RESTART_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-i\" || args[0] == \"--id\" {\n                    let id = args[1].parse::\u003cu128\u003e();\n                    match id {\n                        Ok(i) =\u003e {\n                            options.insert(\"id\".to_string(), Opt::U128(i));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n\n            let req = entity::Request {\n                name: \"restart\".to_string(),\n                command: entity::Command {\n                    name: \"restart\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","resume.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst RESUME_HELP: \u0026str = r#\"Usage: watchmen resume [OPTION...] ...\n    -h, --help      display this help of 'resume' command\n\n    -i, --id        task id\n    -n, --name      task name\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(RESUME_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(RESUME_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-i\" || args[0] == \"--id\" {\n                    let id = args[1].parse::\u003cu128\u003e();\n                    match id {\n                        Ok(i) =\u003e {\n                            options.insert(\"id\".to_string(), Opt::U128(i));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n\n            let req = entity::Request {\n                name: \"resume\".to_string(),\n                command: entity::Command {\n                    name: \"resume\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","run.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst RUN_HELP: \u0026str = r#\"Usage: watchmen run [OPTION...] ...\n    -h, --help      display this help of 'run' command\n\n    -n, --name      task name\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(RUN_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(RUN_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-o\" || args[0] == \"--origin\" {\n                    let origin = args[1].parse::\u003cu128\u003e();\n                    match origin {\n                        Ok(o) =\u003e {\n                            options.insert(\"pid\".to_string(), Opt::U128(o));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else if args[0] == \"-i\" || args[0] == \"--interval\" {\n                    let interval = args[1].parse::\u003cu128\u003e();\n                    match interval {\n                        Ok(i) =\u003e {\n                            options.insert(\"interval\".to_string(), Opt::U128(i));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n            let req = entity::Request {\n                name: \"run\".to_string(),\n                command: entity::Command {\n                    name: \"run\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","start.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst START_HELP: \u0026str = r#\"Usage: watchmen start [OPTION...] ...\n    -h, --help      display this help of 'start' command\n\n    -i, --id        task id\n    -n, --name      task name\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(START_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(START_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-i\" || args[0] == \"--id\" {\n                    let id = args[1].parse::\u003cu128\u003e();\n                    match id {\n                        Ok(i) =\u003e {\n                            options.insert(\"id\".to_string(), Opt::U128(i));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n\n            let req = entity::Request {\n                name: \"start\".to_string(),\n                command: entity::Command {\n                    name: \"start\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command","stop.rs"],"content":"use std::{collections::HashMap, error::Error};\n\nuse crate::{\n    entity::{self, Opt},\n    socket,\n};\n\nconst STOP_HELP: \u0026str = r#\"Usage: watchmen stop [OPTION...] ...\n    -h, --help     display this help of 'start' command\n\n    -i, --id       task id\n    -n, --name     task name\n    -p, --pid      task pid\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\n\npub async fn run(args: \u0026[String], home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 1 {\n        return Ok(entity::Response::ok(STOP_HELP));\n    }\n    let response = match args[0].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response::ok(STOP_HELP),\n        _ =\u003e {\n            let mut options: HashMap\u003cString, Opt\u003e = HashMap::new();\n\n            let mut args: Vec\u003cString\u003e = args.to_vec();\n            while args.len() \u003e 1 {\n                if args[0] == \"-n\" || args[0] == \"--name\" {\n                    options.insert(\"name\".to_string(), Opt::Str(args[1].clone()));\n                } else if args[0] == \"-p\" || args[0] == \"--pid\" {\n                    let pid = args[1].parse::\u003cu32\u003e();\n                    match pid {\n                        Ok(p) =\u003e {\n                            options.insert(\"pid\".to_string(), Opt::U32(p));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else if args[0] == \"-i\" || args[0] == \"--id\" {\n                    let id = args[1].parse::\u003cu128\u003e();\n                    match id {\n                        Ok(i) =\u003e {\n                            options.insert(\"id\".to_string(), Opt::U128(i));\n                        }\n                        Err(_) =\u003e {\n                            return Ok(entity::Response::f(format!(\n                                \"Arg '{}' must be a number\",\n                                args[0]\n                            )));\n                        }\n                    }\n                } else {\n                    break;\n                }\n                args.remove(0);\n                args.remove(0);\n            }\n\n            let req = entity::Request {\n                name: \"stop\".to_string(),\n                command: entity::Command {\n                    name: \"stop\".to_string(),\n                    options: options,\n                    args: args,\n                },\n            };\n            let res = socket::request(\u0026req, home_path).await?;\n            res\n        }\n    };\n    Ok(response)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","command.rs"],"content":"pub mod add;\npub mod exit;\npub mod list;\npub mod pause;\npub mod restart;\npub mod resume;\npub mod run;\npub mod start;\npub mod stop;\n\nuse std::fs::remove_file;\nuse std::io::Write;\nuse std::process::Stdio;\nuse std::{collections::HashMap, error::Error};\nuse tokio::process::Command;\n\nuse crate::{command, entity, socket};\n\nconst HELP: \u0026str = r#\"Usage: watchmen [OPTION|SUBCOMMAND] ...\n    -h, --help        display this help\n    -v, --version     display version\n    -i, --info        display information\n\n    -d, --daemon      startup watchmen daemon\n    -t, --terminated  terminated watchmen daemon\n\n    -gd, --guard-daemon         startup watchmen daemon\n    -gt, --guardt-terminated    terminated watchmen daemon\n\n    run\n        create a task and run it\n        run `watchmen run -h` for more information\n\n    add\n        create a task but not run it\n        run `watchmen add -h` for more information\n\n    drop | exit | rm\n        stop and drop a task\n        run `watchmen [this] -h` for more information\n\n    start\n        start a task if it is exists\n        run `watchmen start -h` for more information\n\n    restart\n        restart a task\n        run `watchmen restart -h` for more information\n\n    stop\n        stop a task\n        run `watchmen stop -h` for more information\n\n    pause\n        pause a scheduled task\n        run `watchmen stop -h` for more information\n\n    resume\n        resume a scheduled task\n        run `watchmen stop -h` for more information\n\n    list\n        list tasks\n        run `watchmen list -h` for more information\n\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\nconst INFO: \u0026str = r#\"watchmen 0.1.0\nHomepage: https://watchmen.ahriknow.com/\"\nReport bugs to ahriknow@ahriknow.com\nIssues: https://git.ahriknow.com/ahriknow/watchmen/issues\"#;\nconst VERSION: \u0026str = \"watchmen 0.1.0\";\n\npub async fn exec(\n    args: Vec\u003cString\u003e,\n    home_path: String,\n) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let len = args.len();\n    if len \u003c 2 {\n        return Ok(entity::Response::ok(HELP));\n    }\n    let response: entity::Response = match args[1].as_str() {\n        \"-h\" | \"--help\" =\u003e entity::Response {\n            code: 10000,\n            msg: HELP.to_string(),\n            data: None,\n        },\n        \"-i\" | \"--info\" =\u003e entity::Response {\n            code: 10000,\n            msg: INFO.to_string(),\n            data: None,\n        },\n        \"-v\" | \"--version\" =\u003e entity::Response {\n            code: 10000,\n            msg: VERSION.to_string(),\n            data: None,\n        },\n        \"run\" =\u003e command::run::run(\u0026args[2..], home_path).await?,\n        \"add\" =\u003e command::add::run(\u0026args[2..], home_path).await?,\n        \"exit\" | \"rm\" | \"drop\" =\u003e command::exit::run(\u0026args[2..], home_path).await?,\n        \"start\" =\u003e command::start::run(\u0026args[2..], home_path).await?,\n        \"restart\" =\u003e command::restart::run(\u0026args[2..], home_path).await?,\n        \"stop\" =\u003e command::stop::run(\u0026args[2..], home_path).await?,\n        \"pause\" =\u003e command::pause::run(\u0026args[2..], home_path).await?,\n        \"resume\" =\u003e command::resume::run(\u0026args[2..], home_path).await?,\n        \"list\" =\u003e command::list::run(\u0026args[2..], home_path).await?,\n        \"-d\" | \"--daemon\" =\u003e start_daemon(\u0026args[2..], home_path).await?,\n        \"-t\" | \"--terminated\" =\u003e terminated_daemon(\u0026args[2..], home_path).await?,\n        \"-gd\" | \"--guard-daemon\" =\u003e start_guard_daemon(\u0026args[2..], home_path).await?,\n        \"-gt\" | \"--guardt-terminated\" =\u003e terminated_guard_daemon(\u0026args[2..], home_path).await?,\n        _ =\u003e {\n            let err: String = format!(\"watchmen: invalid command option '{}'\", args[1]);\n            entity::Response {\n                code: 40000,\n                msg: err,\n                data: None,\n            }\n        }\n    };\n\n    Ok(response)\n}\n\nasync fn start_daemon(\n    _args: \u0026[String],\n    home_path: String,\n) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let watchmen_path = std::path::Path::new(\u0026home_path);\n\n    let stdout_path = watchmen_path.join(\"stdout/\").clone();\n\n    let daemon_stdout = watchmen_path.join(\"daemon.log\").clone();\n    let file_result = std::fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(daemon_stdout.clone());\n    if file_result.is_err() {\n        let err: String = format!(\n            \"watchmen: cannot open stdout file '{}'\",\n            daemon_stdout.to_str().unwrap()\n        );\n        return Ok(entity::Response::err(err));\n    }\n    let stdout = Stdio::from(file_result.unwrap());\n\n    let sock_path = watchmen_path.join(\"watchmen.sock\");\n\n    let path = std::env::current_dir()?.join(\"daemon\");\n    // 子进程\n    let mut child = Command::new(path)\n        .arg(sock_path)\n        .arg(watchmen_path)\n        .arg(stdout_path)\n        .stdout(stdout)\n        .spawn()?;\n\n    let result = child.id();\n\n    match result {\n        Some(pid) =\u003e {\n            // 保存 pid\n            let path = std::path::Path::new(\u0026home_path);\n            let path = path.join(\"daemon.pid\");\n            // 创建文件\n            let mut file = std::fs::File::create(path.clone())?;\n            // 写入 pid\n            file.write_all(pid.to_string().as_bytes())?;\n\n            tokio::spawn(async move {\n                child.wait().await.unwrap();\n                remove_file(path).unwrap_or_default();\n            });\n            Ok(entity::Response::ok(format!(\"Start daemon pid: {}\", pid)))\n        }\n        None =\u003e Ok(entity::Response::err(\"watchmen: failed to start daemon\")),\n    }\n}\n\nextern \"C\" {\n    pub fn kill(pid: i32, sig: i32) -\u003e i32;\n}\n\nasync fn terminated_daemon(\n    args: \u0026[String],\n    home_path: String,\n) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let mut signal = 15;\n    if args.len() == 1 {\n        match args[0].as_str() {\n            \"-f\" | \"--force\" | \"-9\" =\u003e {\n                signal = 9;\n            }\n            _ =\u003e {\n                let err: String = format!(\"Invalid signal: '{}'\", args[0]);\n                return Err(err.into());\n            }\n        }\n    }\n\n    let daemon_pid_path = std::path::Path::new(\u0026home_path).join(\"daemon.pid\");\n    if !daemon_pid_path.exists() {\n        return Ok(entity::Response::err(format!(\n            \"Pid file not exists: {}\",\n            daemon_pid_path.display()\n        )));\n    }\n    let pid = std::fs::read_to_string(daemon_pid_path.clone())?;\n    let pid = pid.parse::\u003ci32\u003e()?;\n    let res = unsafe { kill(pid, signal) };\n    if res == 0 {\n        // 删除文件\n        remove_file(daemon_pid_path).unwrap_or_default();\n        return Ok(entity::Response::ok(format!(\n            \"Terminated daemon pid: {}\",\n            pid\n        )));\n    } else if res == -1 {\n        return Ok(entity::Response::err(format!(\n            \"Daemon process not exists: {}\",\n            pid\n        )));\n    } else {\n        return Ok(entity::Response::err(format!(\n            \"Terminated daemon error code: {}\",\n            res\n        )));\n    }\n}\n\nasync fn start_guard_daemon(\n    _args: \u0026[String],\n    home_path: String,\n) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let watchmen_path = std::path::Path::new(\u0026home_path);\n\n    let stdout_path = watchmen_path.join(\"stdout/\").clone();\n\n    let daemon_stdout = watchmen_path.join(\"guard.log\").clone();\n    let file_result = std::fs::OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(daemon_stdout.clone());\n    if file_result.is_err() {\n        let err: String = format!(\n            \"watchmen: cannot open stdout file '{}'\",\n            daemon_stdout.to_str().unwrap()\n        );\n        return Ok(entity::Response::err(err));\n    }\n    let stdout = Stdio::from(file_result.unwrap());\n\n    let sock_path = watchmen_path.join(\"watchmen.sock\");\n\n    let path = std::env::current_dir()?.join(\"guard\");\n    // 子进程\n    let mut child = Command::new(path)\n        .arg(sock_path)\n        .arg(watchmen_path)\n        .arg(stdout_path)\n        .stdout(stdout)\n        .spawn()?;\n\n    let result = child.id();\n\n    match result {\n        Some(pid) =\u003e {\n            // 保存 pid\n            let path = std::path::Path::new(\u0026home_path);\n            let path = path.join(\"guard.pid\");\n            // 创建文件\n            let mut file = std::fs::File::create(path.clone())?;\n            // 写入 pid\n            file.write_all(pid.to_string().as_bytes())?;\n\n            tokio::spawn(async move {\n                child.wait().await.unwrap();\n                remove_file(path).unwrap_or_default();\n            });\n            Ok(entity::Response::ok(format!(\"Start guard pid: {}\", pid)))\n        }\n        None =\u003e Ok(entity::Response::err(\"watchmen: failed to start daemon\")),\n    }\n}\n\nasync fn terminated_guard_daemon(\n    _args: \u0026[String],\n    home_path: String,\n) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    let options: HashMap\u003cstd::string::String, entity::Opt\u003e = HashMap::new();\n    let req = entity::Request {\n        name: \"terminated\".to_string(),\n        command: entity::Command {\n            name: \"terminated\".to_string(),\n            options: options,\n            args: vec![],\n        },\n    };\n    let res = socket::request(\u0026req, home_path.clone()).await?;\n    if res.code == 10 {\n        let path = std::path::Path::new(\u0026home_path).join(\"daemon.pid\");\n        remove_file(path).unwrap_or_default();\n    }\n    Ok(res)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","entity.rs"],"content":"use std::collections::HashMap;\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Task {\n    pub id: u128,\n    pub name: String,\n    pub command: String,\n    pub args: Vec\u003cString\u003e,\n    pub status: String,\n    pub pid: u32,\n    pub created_at: u128,\n    pub started_at: u128,\n    pub exited_at: u128,\n    pub stopped_at: u128,\n    pub laststart_at: u128,\n    pub exit_code: u32,\n    pub interval: u128,\n    pub origin: u128,\n    pub timing: Vec\u003cu128\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub enum Opt {\n    U128(u128),\n    U128s(Vec\u003cu128\u003e),\n    U32(u32),\n    Str(String),\n    None,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Command {\n    pub name: String,\n    pub options: HashMap\u003cString, Opt\u003e,\n    pub args: Vec\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Request {\n    pub name: String,\n    pub command: Command,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub enum Data {\n    TaskList(Vec\u003cTask\u003e),\n    None,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Response {\n    pub code: u32,\n    pub msg: String,\n    pub data: Option\u003cData\u003e,\n}\n\nimpl Response {\n    pub fn new(code: u32, msg: String, data: Option\u003cData\u003e) -\u003e Self {\n        Self { code, msg, data }\n    }\n\n    pub fn ok\u003cT: ToString\u003e(msg: T) -\u003e Self {\n        Self {\n            code: 10000,\n            msg: msg.to_string(),\n            data: None,\n        }\n    }\n\n    pub fn data\u003cT: ToString\u003e(msg: T, data: Option\u003cData\u003e) -\u003e Self {\n        Self {\n            code: 10000,\n            msg: msg.to_string(),\n            data: data,\n        }\n    }\n\n    pub fn err\u003cT: ToString\u003e(msg: T) -\u003e Self {\n        Self {\n            code: 40000,\n            msg: msg.to_string(),\n            data: None,\n        }\n    }\n\n    pub fn f\u003cT: ToString\u003e(msg: T) -\u003e Self {\n        Self {\n            code: 40000,\n            msg: msg.to_string(),\n            data: None,\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","lib.rs"],"content":"pub mod command;\npub mod entity;\npub mod socket;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","main.rs"],"content":"use clap::Parser;\nuse colored::Colorize;\nuse std::{env, error::Error, fs, process::exit};\n\nuse common::arg::TaskArgs;\nuse watchmen::command;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    let args = TaskArgs::parse();\n    if args.version {\n        println!(\n            \"{} {}\",\n            \"Watchmen rust\".green(),\n            env!(\"CARGO_PKG_VERSION\").green()\n        );\n        return Ok(());\n    }\n    println!(\"{:?}\", args);\n    return Ok(());\n    let watchmen_path = env::var(\"WATCHMEN_PATH\").unwrap_or_else(|_| \"/tmp/watchmen\".to_string());\n\n    let sock_path = std::path::Path::new(\u0026watchmen_path);\n\n    if !sock_path.exists() {\n        match fs::create_dir_all(sock_path) {\n            Ok(_) =\u003e {\n                println!(\"{} {}\", \"Created watchmen path: \".green(), watchmen_path);\n            }\n            Err(err) =\u003e {\n                eprintln!(\"{} {}\", \"Error creating watchmen path: \".red(), err);\n                exit(1);\n            }\n        }\n    }\n\n    let stdout_path = sock_path.join(\"stdout/\").clone();\n    if !stdout_path.exists() {\n        match fs::create_dir(stdout_path.clone()) {\n            Ok(_) =\u003e {\n                println!(\n                    \"{} {}\",\n                    \"Created stdout path: \".green(),\n                    stdout_path.display()\n                );\n            }\n            Err(err) =\u003e {\n                eprintln!(\"{} {}\", \"Error creating stdout path: \".red(), err);\n                exit(1);\n            }\n        }\n    }\n\n    // 命令行参数 / command line arguments\n    let args: Vec\u003cString\u003e = std::env::args().collect();\n    // 执行命令 / execute command\n    let response = command::exec(args, watchmen_path).await;\n    match response {\n        Ok(res) =\u003e {\n            let code;\n            if res.code == 10 {\n                println!(\"{}\", res.msg.green());\n                code = 0;\n            } else if res.code \u003e= 50000 {\n                println!(\"{}\", res.msg.blue());\n                code = 1;\n            } else if res.code \u003e= 40000 {\n                println!(\"{}\", res.msg.red());\n                code = 1;\n            } else if res.code \u003e= 20000 {\n                println!(\"{}\", res.msg.yellow());\n                code = 1;\n            } else if res.code \u003e= 10000 {\n                println!(\"{}\", res.msg.green());\n                code = 0;\n            } else {\n                println!(\"{}\", res.msg);\n                code = 1;\n            }\n            exit(code);\n        }\n        Err(err) =\u003e {\n            eprintln!(\"{}\", err);\n            exit(1);\n        }\n    }\n}\n\n#[cfg(test)]\npub mod tests {\n\n    #[test]\n    fn test_clap() {\n        unsafe {\n            let lib = libloading::Library::new(\"/tmp/watchmen/plugins/libplugin.so\").unwrap();\n            let func: libloading::Symbol\u003cunsafe extern \"C\" fn(t: i32) -\u003e bool\u003e =\n                lib.get(b\"func_plugin\").unwrap();\n            println!(\"PLUGIN: {:?}\", func(1));\n        }\n        assert_eq!(1, 1);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","ahri","watchmen","watchmen","src","socket.rs"],"content":"use std::{error::Error, path::Path};\nuse tokio::{\n    io::{AsyncReadExt, AsyncWriteExt},\n    net::UnixStream,\n};\n\nuse crate::entity;\n\npub async fn request(request: \u0026entity::Request, home_path: String) -\u003e Result\u003centity::Response, Box\u003cdyn Error\u003e\u003e {\n    // 判断文件夹是否存在\n    let path = Path::new(\u0026home_path);\n\n    let socket_path: \u0026Path = \u0026path.join(\"watchmen.sock\");\n    if !socket_path.exists() {\n        return Err(\"Daemon is not running\".into());\n    }\n    let mut stream = UnixStream::connect(socket_path).await?;\n    // Send request\n    let buf = serde_json::to_vec(request)?;\n    stream.write_all(\u0026buf).await?;\n    // 接收数据\n    let mut buf: [u8; 1024] = [0; 1024];\n    let n = stream.read(\u0026mut buf).await?;\n    let res: entity::Response = serde_json::from_slice(\u0026buf[..n])?;\n    Ok(res)\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>